<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BellaBona IntelliRoute - Excel Master</title>

    <!-- External Utilities -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;900&display=swap"
        rel="stylesheet">
    <link href="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.css" rel="stylesheet" />

    <!-- Babel & React/Firebase from CDN -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: #0f172a;
            color: #e2e8f0;
        }

        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #0f172a;
        }

        ::-webkit-scrollbar-thumb {
            background: #334155;
            border-radius: 4px;
        }

        .map-dark-mode canvas {
            filter: invert(100%) hue-rotate(180deg) brightness(95%) contrast(90%);
        }

        .scrollbar-hide::-webkit-scrollbar {
            display: none;
        }

        .excel-grid th,
        .excel-grid td {
            border: 1px solid #334155;
            padding: 4px 8px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .excel-grid th {
            background: #1e293b;
            color: #94a3b8;
            font-weight: bold;
            text-align: left;
        }

        .excel-grid tr:hover {
            background: #1e293b;
        }

        .draggable-item {
            cursor: grab;
        }

        .draggable-item:active {
            cursor: grabbing;
            background: #3730a3;
        }

        .grid-col-driver {
            min-width: 140px;
            border-right: 1px solid #334155;
        }
    </style>

    <!-- Error Handler -->
    <script>
        window.onerror = function (msg, url, line, col, error) {
            document.body.innerHTML = `
                <div style="background:#0f172a;color:#ef4444;padding:40px;font-family:monospace;height:100vh;display:flex;flex-col;justify-content:center;align-items:center;">
                    <div style="max-width:800px;">
                        <h1 style="font-size:24px;margin-bottom:20px;">SYSTEM CRITICAL ERROR</h1>
                        <p style="background:#1e293b;padding:20px;border-radius:10px;border:1px solid #334155;">${msg}</p>
                        <p style="color:#64748b;margin-top:10px;">${url}:${line}:${col}</p>
                    </div>
                </div>
            `;
            console.error("Critical Error:", error);
            return false;
        };
    </script>

    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "@google/generative-ai": "https://esm.sh/@google/generative-ai@0.21.0",
        "firebase/app": "https://www.gstatic.com/firebasejs/10.13.0/firebase-app.js",
        "firebase/firestore": "https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore.js",
        "maplibre-gl": "https://esm.sh/maplibre-gl@4.7.1"
      }
    }
    </script>

    <!-- INJECTED ORDERS DATA (from User Desktop) -->
    <script src="orders_data.js"></script>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel" data-presets="react" data-type="module">
        import React, { useState, useEffect, useMemo, useRef } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as firebaseApp from 'firebase/app';
        import {
            getFirestore,
            initializeFirestore,
            persistentLocalCache,
            persistentMultipleTabManager,
            collection,
            doc,
            setDoc,
            getDoc,
            onSnapshot,
            writeBatch
        } from 'firebase/firestore';
        import { GoogleGenerativeAI } from '@google/generative-ai';
        import { Map as MapLibreMap, NavigationControl, AttributionControl, Marker, Popup, LngLatBounds } from 'maplibre-gl';

        console.log("App initializing...");

        // --- CONSTANTS ---
        const POTSDAM_KITCHEN = { lat: 52.3906, lng: 13.0645, address: "Friedrich-Engels-Stra√üe 24, 14473 Potsdam" };

        const DRIVERS = [
            { id: 'samir', name: 'Samir', level: 1, capacity: 16, isActive: true, color: '#f59e0b', zoneAnchor: { lat: 52.5219, lng: 13.4132 } }, // Mitte (Alex)
            { id: 'ali1', name: 'Ali 1', level: 1, capacity: 12, isActive: true, color: '#ec4899', zoneAnchor: { lat: 52.5330, lng: 13.2300 } }, // Spandau/West
            { id: 'ali2', name: 'Ali 2', level: 1, capacity: 10, isActive: true, color: '#ff4500', zoneAnchor: { lat: 52.4800, lng: 13.4300 } }, // Neuk√∂lln
            { id: 'ali3', name: 'Ali 3', level: 2, capacity: 12, isActive: true, color: '#32cd32', zoneAnchor: { lat: 52.4200, lng: 13.5000 } }, // South East
            { id: 'ali4', name: 'Ali 4', level: 2, capacity: 12, isActive: true, color: '#00ced1', zoneAnchor: { lat: 52.5200, lng: 13.3000 } }, // Charlottenburg
            { id: 'ankush', name: 'Ankush', level: 3, capacity: 12, isActive: true, color: '#9400d3', zoneAnchor: { lat: 52.5000, lng: 13.3500 } }, // Center West
            { id: 'tasnim', name: 'Tasnim', level: 4, capacity: 16, isActive: true, color: '#ff00ff', zoneAnchor: { lat: 52.5100, lng: 13.3800 } }, // Center (Mitte)
            { id: 'packtor1', name: 'Packator 1', level: 4, capacity: 10, isActive: true, color: '#ffd700', zoneAnchor: { lat: 52.5300, lng: 13.4200 } }, // Prenzlauer Berg
            { id: 'packtor2', name: 'Packator 2', level: 4, capacity: 10, isActive: true, color: '#dc143c', zoneAnchor: { lat: 52.5500, lng: 13.4500 } }, // Weissensee
            { id: 'packtor3', name: 'Packator 3', level: 4, capacity: 10, isActive: true, color: '#adff2f', zoneAnchor: { lat: 52.5000, lng: 13.4500 } }, // Friedrichshain
            { id: 'harsh', name: 'Harsh', level: 2, capacity: 12, isActive: true, color: '#4169e1', zoneAnchor: { lat: 52.5600, lng: 13.3000 } }, // Reinickendorf
            { id: 'josef', name: 'Josef', level: 2, capacity: 12, isActive: true, color: '#000080', zoneAnchor: { lat: 52.4800, lng: 13.3500 } }, // Sch√∂neberg
        ];

        const GOLDEN_PLAN = {
            'samir': ['Ingenierburo', 'Shiftmove', 'Nike', 'King', 'Momox', 'Love', 'Lovehoney', 'Wohnung', 'Team Viewer', 'TeamViewer', 'IFX'],
            'ali1': ['Probio', 'Isi', 'Mektec', 'Pen', 'PenCef', 'Expert', 'Aignostic', 'Koppla'],
            'tasnim': ['Hilton', 'alteos', 'Ritual', 'teufel', 'Lautsprecher', 'Degewo-Kurfurstendam', 'Degewo-Kurf√ºrstenstr', 'Kws', 'Almedia', 'Gsport-YUME', 'nexnet', 'unzer', 'Semrush', 'Adyen', 'Tui', 'Office'],
            'packtor1': ['Core', 'Affinidi', 'Bitpanda', 'Parloa', 'Personio', 'Verve'],
            'ali2': ['Getranke', 'Getr√§nke', 'Joachim', 'Gottschalk', 'Liquid', 'Giantx', 'Heart', 'Berlin Heart', 'Tib', 'Omicron'],
            'josef': ['Viessmann', 'Digital', 'Pomelo', 'Gentlemates', 'Leapsome', 'Degewo-Brunnen', 'Bonial', 'Cognita', 'BCL', 'Charles'],
            'packtor2': ['Bahnhofstr', 'Kayak', 'Omio', 'Mehrower'],
            'ali3': ['Tam', 'Byrd', 'Taxfix', 'OnCloud', 'On Cloud', 'Beyvers', 'Ellabarowsky', 'Ella-Barowsky']
        };

        const DEFAULT_REGISTRY = {
            "Adyen N.V. Berlin": "Br√ºckenstra√üe 5, 10179 Berlin",
            "Aignostics GmbH": "Invalidenstra√üe 112, 10115 Berlin",
            "Almeida GmbH": "Oranienburger Str. 86, 10178 Berlin",
            "Alteos GmbH": "Rotherstra√üe 19, 10245 Berlin",
            "Bahnhofstr - degewo": "Bahnhofstra√üe 23, 12555 Berlin",
            "Berlin Heart": "Wiesenweg 10, 12247 Berlin",
            "Beyvers GmbH Produktion": "Sperenberger Str. 5, 12277 Berlin",
            "Beyvers GmbH Verwaltung": "Sperenberger Str. 5, 12277 Berlin",
            "Bitpanda - German Branch": "Oberwallstra√üe 6, 10117 Berlin",
            "Bonial International": "Hussitenstra√üe 32, 13355 Berlin",
            "Cognita (Switzerland)": "Friedrichstra√üe 68, 10117 Berlin",
            "Degewo-Brunnen": "Brunnenstra√üe 128, 13355 Berlin",
            "Digital Career Institute gGmbH": "Vulkanstra√üe 1, 10367 Berlin",
            "Ella-Barowsky - degewo": "Ella-Barowsky-Stra√üe 6, 10829 Berlin",
            "Expert Systems AG": "Quedlinburger Str. 1, 10589 Berlin",
            "GSport - YUME Service": "M√ºhlenstra√üe 8, 14167 Berlin",
            "Gentlemates - Hive": "Gartenstra√üe 6, 10115 Berlin",
            "Giantx": "Adalbertstra√üe 6, 10999 Berlin",
            "Gottschalk Logistik Systems GmbH": "Hanns-Martin-Schleyer-Stra√üe 11, 41564 Kaarst",
            "Hilton Berlin": "Mohrenstra√üe 30, 10117 Berlin",
            "IFX Payments": "Friedrichstra√üe 68, 10117 Berlin",
            "Ingenierburo": "Reinhardtstra√üe 14, 10117 Berlin",
            "Isi GmbH": "Askanierring 90, 13585 Berlin",
            "Joachim Herz": "Langenbeckstra√üe 1, 10249 Berlin",
            "KWS Berlin": "Potsdamer Str. 3, 10785 Berlin",
            "Kayak": "Stra√üe der Pariser Kommune 8, 10243 Berlin",
            "Koppla GmbH": "Charlottenstra√üe 2, 10969 Berlin",
            "Kurf√ºrstenstr - degewo": "Kurf√ºrstenstra√üe 58, 10785 Berlin",
            "Lautsprecher Teufel": "Budapester Str. 44, 10787 Berlin",
            "Leapsome GmbH": "Brunnenstra√üe 153, 10115 Berlin",
            "Lovehoney Group": "Warschauer Pl. 11, 10245 Berlin",
            "Mehrower Allee - degewo": "Mehrower Allee 52, 12687 Berlin",
            "Mektec Manufacturing": "Nonnendammallee 104, 13629 Berlin",
            "Momox SE": "Schreiberhauer Str. 30, 10317 Berlin",
            "Nike (powered by CBRE) - nike.com": "M√ºhlenstra√üe 25, 10243 Berlin",
            "Omicron Energy Solutions": "Qualit√§tsweg 10, 12277 Berlin",
            "Omio": "Warschauer Pl. 12, 10245 Berlin",
            "On Cloud Service GmbH": "Skalitzer Str. 104, 10997 Berlin",
            "Parloa - Berlin": "Oberwallstra√üe 6, 10117 Berlin",
            "PenCef Pharma GmbH": "Robert-R√∂ssle-Stra√üe 10, 13125 Berlin",
            "Personio Berlin": "Sch√∂nhauser Allee 188, 10119 Berlin",
            "Pluxee - King - Midasplayer Vertriebs GmbH": "Karl-Liebknecht-Str. 32, 10178 Berlin",
            "ProBioGen AG": "Goethestra√üe 54, 13086 Berlin",
            "Safe Labs (ex Core Contributors)": "Fullerstra√üe 6, 12051 Berlin",
            "Semrush - Berlin": "Bernburger Str. 27, 10963 Berlin",
            "Shiftmove": "Oranienstra√üe 6, 10997 Berlin",
            "TAM": "Ritterstra√üe 12, 10969 Berlin",
            "TIB Molbiol Syntheselabor": "Eresburgstra√üe 22, 12103 Berlin",
            "TUI Deutschland - tui.com": "Karl-Liebknecht-Str. 19, 10178 Berlin",
            "Taxfix.de": "K√∂penicker Str. 122, 10179 Berlin",
            "Team Liquid - Liquid Enterprises GmbH": "Warschauer Str. 58, 10243 Berlin",
            "TeamViewer Germany": "Pappelallee 78, 10437 Berlin",
            "Verve Group Europe GmbH": "Karl-Liebknecht-Str. 32, 10178 Berlin",
            "Viessmann Climate Solutions": "Euref-Campus 1, 10829 Berlin",
            "byrd technologies": "Ritterstra√üe 12, 10969 Berlin",
            "charles GmbH": "Gartenstra√üe 6, 10115 Berlin",
            "gentlemates": "Gartenstra√üe 1, 10115 Berlin",
            "nexnet GmbH": "Markgrafenstra√üe 62, 10969 Berlin"
        };

        const firebaseConfig = {
            apiKey: "AIzaSyBCljwsTQ-PHm20VP-i8VByNrRwVFgMl5I",
            authDomain: "routing-4aab8.firebaseapp.com",
            databaseURL: "https://routing-4aab8-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "routing-4aab8",
            storageBucket: "routing-4aab8.firebasestorage.app",
            messagingSenderId: "148497920348",
            appId: "1:148497920348:web:0e14c31aa4dfde00205199"
        };
        const app = firebaseApp.initializeApp(firebaseConfig);
        const db = initializeFirestore(app, {
            ignoreUndefinedProperties: true,
            localCache: persistentLocalCache({ tabManager: persistentMultipleTabManager() })
        });

        // --- COMPONENTS ---
        const RouteMap = ({ tours, onGeocodeUpdate, height, onOrderMove }) => {
            const mapContainer = useRef(null);
            const map = useRef(null);
            const markersRef = useRef([]);
            const processingRef = useRef(new Set());

            useEffect(() => {
                window.handleMoveOrder = (orderId, driverId) => {
                    onOrderMove(orderId, driverId);
                };
            }, [onOrderMove]);



            useEffect(() => {
                if (map.current || !mapContainer.current) return;
                map.current = new MapLibreMap({
                    container: mapContainer.current,
                    style: 'https://tiles.openfreemap.org/styles/bright',
                    center: [13.405, 52.52],
                    zoom: 10,
                    attributionControl: false
                });
                window.mapInstance = map.current; // Expose for GridView interactions
                map.current.addControl(new NavigationControl(), 'top-right');

                // Kitchen Marker REMOVED
                /*
                new Marker({ color: '#ef4444', scale: 1.2 })
                    .setLngLat([POTSDAM_KITCHEN.lng, POTSDAM_KITCHEN.lat])
                    .setPopup(new Popup().setText("KITCHEN: " + POTSDAM_KITCHEN.address))
                    .addTo(map.current);
                */

                return () => { map.current?.remove(); map.current = null; };
            }, []);

            useEffect(() => {
                const queue = tours.flatMap(t => t.orders.filter(o => !o.lat && !processingRef.current.has(o.id)));
                if (queue.length === 0) return;

                const process = async () => {
                    const order = queue[0];
                    if (!order) return;
                    processingRef.current.add(order.id);

                    const query = order.address ? `${order.address}, Berlin, Germany` : `${order.name}, Berlin, Germany`;
                    try {
                        const res = await fetch(`https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(query)}&format=json&limit=1`, {
                            headers: { 'User-Agent': 'BellaBona-IntelliRoute/1.0' }
                        });
                        const data = await res.json();
                        if (data && data.length > 0) {
                            onGeocodeUpdate(order.id, parseFloat(data[0].lat), parseFloat(data[0].lon));
                        }
                    } catch (e) { }
                    setTimeout(process, 1200);
                };
                process();
            }, [tours]);

            useEffect(() => {
                map.current?.resize();
            }, [height]);

            useEffect(() => {
                if (!map.current) return;
                const m = map.current;
                markersRef.current.forEach(mk => mk.remove());
                markersRef.current = [];

                const features = [];
                const bounds = new LngLatBounds();
                // bounds.extend([POTSDAM_KITCHEN.lng, POTSDAM_KITCHEN.lat]); // Removed to focus on delivery zones

                tours.forEach(tour => {
                    const driver = DRIVERS.find(d => d.id === tour.driverId);
                    const color = driver ? driver.color : '#cbd5e1';

                    // Start route from first order, NOT kitchen
                    const coords = [];

                    tour.orders.forEach((o, idx) => {
                        if (o.lng && o.lat) {
                            coords.push([o.lng, o.lat]);
                            bounds.extend([o.lng, o.lat]);

                            const el = document.createElement('div');
                            el.innerHTML = `<div style="background:${color};width:24px;height:24px;border-radius:50%;border:2px solid white;box-shadow:0 2px 4px rgba(0,0,0,0.5);color:white;font-weight:bold;font-size:12px;display:flex;justify-content:center;align-items:center;cursor:pointer;">${idx + 1}</div>`;

                            const driverOptions = DRIVERS.map(d =>
                                `<option value="${d.id}" ${d.id === tour.driverId ? 'selected' : ''}>${d.name}</option>`
                            ).join('');

                            const popupContent = `
                                <div style="font-family:'Inter',sans-serif; min-width:200px;">
                                    <h3 style="font-weight:bold;margin-bottom:4px;">${o.name}</h3>
                                    <p style="font-size:11px;color:#64748b;margin-bottom:8px;">${o.address}</p>
                                    <div style="font-size:11px;font-weight:bold;margin-bottom:8px;">
                                        üì¶ ${o.boxes} Boxes | üçΩÔ∏è ${o.dishes || '?'} Dishes
                                    </div>
                                    <div style="background:#f1f5f9;padding:8px;border-radius:6px;">
                                        <label style="font-size:10px;font-weight:bold;display:block;margin-bottom:4px;color:#475569;">MOVE TO DRIVER:</label>
                                        <select onchange="window.handleMoveOrder('${o.id}', this.value)" style="width:100%;padding:4px;border:1px solid #cbd5e1;border-radius:4px;font-size:12px;">
                                            ${driverOptions}
                                        </select>
                                    </div>
                                </div>
                            `;

                            const marker = new Marker({ element: el })
                                .setLngLat([o.lng, o.lat])
                                .setPopup(new Popup({ maxWidth: '300px' }).setHTML(popupContent))
                                .addTo(m);
                            markersRef.current.push(marker);
                        }
                    });

                    if (coords.length > 1) {
                        features.push({
                            type: 'Feature',
                            properties: { color },
                            geometry: { type: 'LineString', coordinates: coords }
                        });
                    }
                });

                if (m.getSource('routes')) {
                    m.getSource('routes').setData({ type: 'FeatureCollection', features });
                } else if (m.isStyleLoaded()) {
                    m.addSource('routes', { type: 'geojson', data: { type: 'FeatureCollection', features } });
                    // THICK GLOW AND SOLID CORE
                    m.addLayer({ id: 'routes-glow', type: 'line', source: 'routes', paint: { 'line-color': ['get', 'color'], 'line-width': 8, 'line-opacity': 0.4, 'line-blur': 2 } });
                    m.addLayer({ id: 'routes-line', type: 'line', source: 'routes', paint: { 'line-color': ['get', 'color'], 'line-width': 3, 'line-opacity': 1 } });
                }

                if (!bounds.isEmpty()) m.fitBounds(bounds, { padding: 80 });
            }, [tours]);

            return <div ref={mapContainer} className="w-full h-full" />;
        };

        const GridView = ({ tours, setTours, packerNames, setPackerNames, onSave, registry }) => {
            const handleOrderClick = (lat, lng, name) => {
                if (lat && lng && window.mapInstance) {
                    window.mapInstance.flyTo({ center: [lng, lat], zoom: 14, speed: 1.5 });
                    // Optional: Trigger popup if we had reference to markers, but flyTo is good enough for now
                }
            };
            const draggedItem = useRef(null);
            const draggedOverItem = useRef(null);

            const handleDragStart = (e, tourIdx, orderIdx) => {
                draggedItem.current = { tourIdx, orderIdx };
                e.dataTransfer.effectAllowed = 'move';
            };

            const handleDragEnter = (e, tourIdx, orderIdx) => {
                draggedOverItem.current = { tourIdx, orderIdx };
            };

            const handleDrop = (e) => {
                const source = draggedItem.current;
                const dest = draggedOverItem.current;
                if (!source || !dest) return;

                const newTours = [...tours];
                const sourceTour = newTours[source.tourIdx];
                const destTour = newTours[dest.tourIdx];

                const [movedOrder] = sourceTour.orders.splice(source.orderIdx, 1);

                if (dest.orderIdx >= destTour.orders.length) {
                    destTour.orders.push(movedOrder);
                } else {
                    destTour.orders.splice(dest.orderIdx, 0, movedOrder);
                }

                setTours(newTours);
                draggedItem.current = null;
                draggedOverItem.current = null;
            };

            return (
                <div className="flex bg-slate-900 border border-slate-700 h-full overflow-x-auto rounded-lg">
                    {tours.map((tour, tIdx) => {
                        const driver = DRIVERS.find(d => d.id === tour.driverId);
                        return (
                            <div key={tour.driverId}
                                className="grid-col-driver flex-1 min-w-[160px] flex flex-col border-r border-slate-700 last:border-r-0"
                                onDragEnter={(e) => handleDragEnter(e, tIdx, tour.orders.length)}
                                onDragOver={(e) => e.preventDefault()}
                                onDrop={handleDrop}
                            >
                                <div className="p-2 border-b border-slate-700 text-center font-bold text-sm" style={{ backgroundColor: driver?.color, color: '#000' }}>
                                    {driver?.name}
                                </div>
                                <div className="flex-1 overflow-y-auto p-1 space-y-1">
                                    {tour.orders.map((order, oIdx) => {
                                        const isLate = order.estimatedArrival && order.deadlineMinutes && order.estimatedArrival > order.deadlineMinutes;
                                        const arrivalTime = order.estimatedArrival
                                            ? `${Math.floor(order.estimatedArrival / 60)}:${String(Math.floor(order.estimatedArrival % 60)).padStart(2, '0')}`
                                            : null;

                                        return (
                                            <div key={order.id}
                                                draggable
                                                onDragStart={(e) => handleDragStart(e, tIdx, oIdx)}
                                                onDragEnter={(e) => { e.stopPropagation(); handleDragEnter(e, tIdx, oIdx); }}
                                                onDragOver={(e) => e.preventDefault()}
                                                onClick={() => handleOrderClick(order.lat, order.lng, order.name)}
                                                className="bg-slate-800 p-2 rounded text-xs border border-slate-600 cursor-pointer hover:bg-slate-700 draggable-item relative group hover:border-indigo-500 transition-all shadow-sm"
                                            >
                                                <div className="font-bold truncate flex items-center gap-1" title={order.name}>
                                                    <span className="text-slate-500 text-[10px] w-4">{oIdx + 1}.</span>
                                                    {order.name}
                                                </div>
                                                <div className="text-[10px] text-slate-400 truncate">{order.address?.split(',')[0]}</div>
                                                <div className="flex gap-2 mt-1 items-center justify-between">
                                                    <div className="flex gap-1">
                                                        <span className="bg-slate-700 px-1 rounded text-[9px] text-slate-300">üì¶ {order.boxes}</span>
                                                        <span className="bg-indigo-900 px-1 rounded text-[9px] text-indigo-300">üçΩÔ∏è {order.dishes || '?'}</span>
                                                    </div>
                                                    <div className="text-right flex flex-col items-end">
                                                        {(() => {
                                                            // Live Lookup for Eating Time
                                                            const regEntry = registry && registry[order.name];
                                                            // Try live registry first, then order snapshot, then ignore
                                                            const eTimeStr = regEntry?.eatingTime || order.registryEatingTime;

                                                            if (eTimeStr) {
                                                                const [eh, em] = eTimeStr.split(':').map(Number);
                                                                const eTimeMins = eh * 60 + em;
                                                                // Recalculate late status based on live data if needed, but for now just show the time
                                                                return (
                                                                    <span className="text-[9px] text-orange-400 font-mono mb-0.5" title={`Eating Time: ${eTimeStr}`}>
                                                                        üçΩÔ∏è {eh}:{String(em).padStart(2, '0')}
                                                                    </span>
                                                                );
                                                            } else if (order.eatingTimeMinutes) {
                                                                // Fallback to calculated/estimated
                                                                return (
                                                                    <span className="text-[9px] text-orange-400/50 font-mono mb-0.5" title="Estimated Eating Time">
                                                                        üçΩÔ∏è {Math.floor(order.eatingTimeMinutes / 60)}:{String(order.eatingTimeMinutes % 60).padStart(2, '0')}
                                                                    </span>
                                                                );
                                                            }
                                                            return null;
                                                        })()}

                                                        {arrivalTime && (
                                                            <span className={`px-1 rounded text-[9px] font-bold ${isLate ? 'bg-red-900 text-red-300' : 'bg-emerald-900 text-emerald-300'}`}>
                                                                {isLate ? '‚ö†Ô∏è' : '‚úì'} {arrivalTime}
                                                            </span>
                                                        )}
                                                    </div>
                                                </div>
                                            </div>
                                        )
                                    })}
                                    {tour.orders.length === 0 && (
                                        <div className="text-center text-slate-600 text-xs italic mt-4">Empty</div>
                                    )}
                                </div>
                                <div className="p-2 border-t border-slate-700 text-[10px] text-center text-slate-400">
                                    {tour.orders.length} stops
                                </div>
                                <div className="p-2 border-t border-slate-700">
                                    <label className="text-[9px] text-slate-500 block mb-1">Packer:</label>
                                    <input
                                        type="text"
                                        placeholder="Who packs this?"
                                        value={packerNames[tour.driverId] || ''}
                                        onChange={(e) => {
                                            const newPackerNames = { ...packerNames, [tour.driverId]: e.target.value };
                                            setPackerNames(newPackerNames);
                                        }}
                                        onBlur={() => onSave(tours)}
                                        className="w-full bg-slate-800 text-slate-300 text-xs px-2 py-1 rounded border border-slate-600 focus:outline-none focus:border-indigo-500"
                                    />
                                </div>
                            </div>
                        );
                    })}
                </div>
            );
        };

        const RegistryView = ({ registry }) => {

            const save = async (name, newAddress) => {
                try {
                    await setDoc(doc(db, "registry", name), { address: newAddress });
                } catch (e) {
                    console.error("Error saving to registry", e);
                    alert("Failed to save to cloud");
                }
            };

            return (
                <div className="p-8 text-white">
                    <h2 className="text-2xl font-bold mb-4">Cloud Company Registry</h2>
                    <p className="mb-4 text-slate-400">Manage customer addresses here. Data is synced to the cloud.</p>

                    <div className="grid grid-cols-2 gap-4">
                        {Object.entries(registry)
                            .sort(([a], [b]) => a.localeCompare(b)) // Alphabetical sort
                            .map(([name, data]) => (
                                <div key={name} className="bg-slate-800 p-4 rounded border border-slate-600">
                                    <input className="bg-transparent font-bold w-full mb-2 border-b border-slate-600 focus:outline-none" defaultValue={name} readOnly />
                                    <input
                                        className="bg-slate-900 w-full p-2 rounded text-sm text-slate-300"
                                        defaultValue={data.address}
                                        onBlur={(e) => save(name, e.target.value)}
                                    />
                                </div>
                            ))}
                    </div>
                    <button className="mt-4 bg-indigo-600 px-4 py-2 rounded font-bold" onClick={() => {
                        const name = prompt("Enter Company Name");
                        if (name) save(name, "");
                    }}>+ Add New Company</button>
                </div>
            )
        }

        function App() {
            const [selectedDate, setSelectedDate] = useState(() => new Date().toISOString().split('T')[0]);
            const [tours, setTours] = useState([]);
            const [view, setView] = useState('grid');
            const [loading, setLoading] = useState(false);
            const [showCalendar, setShowCalendar] = useState(false);
            const [showDriverDropdown, setShowDriverDropdown] = useState(false);
            const [driverAvailability, setDriverAvailability] = useState({});
            const [packerNames, setPackerNames] = useState({});
            const [gridHeight, setGridHeight] = useState(50); // Percentage of screen
            const [uploadProgress, setUploadProgress] = useState(0); // Progress percentage
            const [showRecovery, setShowRecovery] = useState(false);
            const [registry, setRegistry] = useState({});
            const processingRef = useRef(false); // Used for seeding check

            useEffect(() => {
                // Load Registry from Firestore
                const unsubscribe = onSnapshot(collection(db, "registry"), async (snapshot) => {
                    const data = {};
                    snapshot.forEach(doc => {
                        data[doc.id] = doc.data();
                    });

                    if (Object.keys(data).length === 0 && !processingRef.current) {
                        processingRef.current = true;
                        console.log("Seeding Registry with Defaults...");
                        setRegistry(Object.fromEntries(Object.entries(DEFAULT_REGISTRY).map(([k, v]) => [k, { address: v }])));

                        const batch = writeBatch(db);
                        Object.entries(DEFAULT_REGISTRY).forEach(([name, addr]) => {
                            const docRef = doc(db, "registry", name);
                            batch.set(docRef, { address: addr });
                        });
                        try { await batch.commit(); } catch (e) { console.error("Seed failed", e); }
                    } else {
                        setRegistry(data);
                    }
                });
                return () => unsubscribe();
            }, []);

            // Load driver availability for selected date
            useEffect(() => {
                const loadAvailability = async () => {
                    try {
                        const docRef = doc(db, "driver_availability", selectedDate);
                        const docSnap = await getDoc(docRef);

                        if (docSnap.exists()) {
                            setDriverAvailability(docSnap.data().drivers || {});
                        } else {
                            // Default: all drivers ON
                            const defaultAvail = {};
                            DRIVERS.forEach(d => { defaultAvail[d.id] = true; });
                            setDriverAvailability(defaultAvail);
                        }
                    } catch (e) {
                        console.error("Error loading availability:", e);
                    }
                };
                loadAvailability();
            }, [selectedDate]);

            useEffect(() => {
                const loadPlan = async () => {
                    setLoading(true);
                    try {
                        const docRef = doc(db, "daily_plans", selectedDate);
                        const docSnap = await getDoc(docRef);

                        if (docSnap.exists()) {
                            const data = docSnap.data();
                            if (data.tours) {
                                // Ensure all current drivers are in the loaded plan (Migration Fix)
                                const loadedTours = data.tours;
                                const mergedTours = [...loadedTours];
                                DRIVERS.forEach(d => {
                                    if (!mergedTours.find(t => t.driverId === d.id)) {
                                        mergedTours.push({ driverId: d.id, driverName: d.name, orders: [] });
                                    }
                                });
                                setTours(mergedTours);
                                setPackerNames(data.packerNames || {});
                                console.log("Loaded plan for", selectedDate);
                            }
                        } else {
                            setTours([]);
                            setPackerNames({});
                        }
                    } catch (e) {
                        console.error("Error loading plan:", e);
                    } finally {
                        setLoading(false);
                    }
                };
                loadPlan();
            }, [selectedDate]);

            const toggleDriverAvailability = async (driverId) => {
                const newAvail = { ...driverAvailability, [driverId]: !driverAvailability[driverId] };
                setDriverAvailability(newAvail);

                // Save to Firebase
                try {
                    await setDoc(doc(db, "driver_availability", selectedDate), {
                        date: selectedDate,
                        drivers: newAvail,
                        lastUpdated: new Date().toISOString()
                    });
                } catch (e) {
                    console.error("Error saving availability:", e);
                }
            };

            const handleOrderMove = (orderId, targetDriverId) => {
                const newTours = [...tours];
                let movedOrder = null;

                // Find and remove order
                newTours.forEach(tour => {
                    const idx = tour.orders.findIndex(o => o.id === orderId);
                    if (idx !== -1) {
                        movedOrder = tour.orders.splice(idx, 1)[0];
                    }
                });

                // Add to target driver
                if (movedOrder && targetDriverId) {
                    const targetTour = newTours.find(t => t.driverId === targetDriverId);
                    if (targetTour) {
                        targetTour.orders.push(movedOrder);
                    }
                }

                setTours(newTours);
                // Auto-save on move? Maybe better to have explicit save or debounce.
                // For now, let's just update local state. User can re-upload to reset or we should add a "Save" button. 
                // Actually, let's auto-save to cloud on move for seamless experience.
                saveDailyPlan(newTours);
            };

            const [showUpload, setShowUpload] = useState(false);

            const saveDailyPlan = async (currentTours) => {
                // Use the currently selected date
                try {
                    await setDoc(doc(db, "daily_plans", selectedDate), {
                        date: selectedDate,
                        tours: currentTours,
                        drivers: DRIVERS,
                        packerNames: packerNames,
                        lastUpdated: new Date().toISOString()
                    });
                    console.log("Daily plan saved for " + selectedDate);
                } catch (e) {
                    console.error("Error saving daily plan", e);
                }
            };

            const processJsonData = async (jsonContent) => {
                setUploadProgress(1);
                try {
                    const json = JSON.parse(jsonContent);
                    let orders = Array.isArray(json) ? json : (json.orders || []);

                    // FILTER OUT INTERNAL ORDERS
                    orders = orders.filter(o => {
                        const name = (o.name || "").toLowerCase();
                        if (name.includes("bella") && name.includes("bona") && (name.includes("kitchen") || name.includes("potsdam"))) {
                            console.log("üö´ Filtered internal order:", o.name);
                            return false;
                        }
                        return true;
                    });

                    orders = orders.map(o => {
                        const boxCount = Array.isArray(o.boxes) ? o.boxes.length : (Number(o.boxes) || 1);

                        let dishCount = 0;
                        if (typeof o.dishes === 'number') {
                            dishCount = o.dishes;
                        } else if (Array.isArray(o.boxes)) {
                            // Try to extract dish count from nested structure similar to python logic
                            // Structure: box -> dishes -> users -> orderedQuantity
                            dishCount = o.boxes.reduce((acc, box) => {
                                const boxDishes = Array.isArray(box.dishes) ? box.dishes : [];
                                return acc + boxDishes.reduce((dAcc, dish) => {
                                    const users = Array.isArray(dish.users) ? dish.users : [];
                                    return dAcc + users.reduce((uAcc, user) => uAcc + (user.orderedQuantity || 0), 0);
                                }, 0);
                            }, 0);
                            // If deep extraction yielded 0 but we have boxes, maybe dishes are just counted differently or missing.
                            if (dishCount === 0 && o.dishes) dishCount = Number(o.dishes) || 0;
                        } else {
                            dishCount = Number(o.dishes) || 0;
                        }

                        return {
                            id: o.id || Math.random().toString(36),
                            name: o.name || "Unknown",
                            address: (o.address || "") + (o.postCode || o.zipCode || o.postal_code || o.zip ? `, ${o.postCode || o.zipCode || o.postal_code || o.zip}` : ""),
                            postCode: o.postCode || o.zipCode || o.postal_code || o.zip || "",
                            boxes: boxCount,
                            dishes: dishCount,
                            deliverySlotStart: o.deliverySlotStart || "09:00",
                            deliverySlotEnd: o.deliverySlotEnd || "12:00"
                        };
                    });

                    const newTours = await calculateInitialTours(orders);
                    setUploadProgress(90); // Optimization phase
                    setTours(newTours); // Update UI immediately
                    await saveDailyPlan(newTours);
                    setUploadProgress(100);
                    setTimeout(() => {
                        setShowUpload(false);
                        setUploadProgress(0);
                    }, 500);
                } catch (err) {
                    alert("Invalid JSON format");
                    setUploadProgress(0);
                }
            };


            // Geocoding cache - stores coordinates for addresses to avoid repeated API calls
            const geocodeCache = useRef({});
            const registryRef = useRef({});

            // Load geocoding cache from Firebase
            useEffect(() => {
                const unsubscribe = onSnapshot(collection(db, "geocode_cache"), (snapshot) => {
                    const cache = {};
                    snapshot.forEach(doc => {
                        cache[doc.id] = doc.data();
                    });
                    geocodeCache.current = cache;
                    console.log("Geocode cache loaded:", Object.keys(cache).length, "addresses");
                });
                return () => unsubscribe();
            }, []);

            // Sync registry state to ref for geocoding
            useEffect(() => {
                registryRef.current = registry;
            }, [registry]);

            // Geocode an address and cache the result
            const geocodeAddress = async (address, companyName) => {
                // HARDCODED FIXES for companies with bad geocoding results
                const MANUAL_GEOCODES = {
                    "Alteos": { lat: 52.50356, lng: 13.33917 },
                    "Semrush": { lat: 52.5074, lng: 13.3904 }
                };

                // Check for Manual Overrides (Partial Match)
                if (companyName) {
                    for (const [key, coords] of Object.entries(MANUAL_GEOCODES)) {
                        if (companyName.toLowerCase().includes(key.toLowerCase())) {
                            console.log(`üìç Using Manual Geocode for ${companyName}`);
                            return coords;
                        }
                    }
                }

                // Check cache first
                const cacheKey = companyName || address;
                if (geocodeCache.current[cacheKey]) {
                    const cached = geocodeCache.current[cacheKey];
                    if (cached.lat && cached.lng) {
                        console.log("‚úÖ Cache hit for:", cacheKey);
                        return { lat: cached.lat, lng: cached.lng };
                    }
                }

                // Geocode using Nominatim
                try {
                    // Improve Query: Always append "Berlin, Germany" for context if not already present
                    let query = address || companyName; // Use address if available, otherwise companyName
                    if (!query.toLowerCase().includes("berlin")) query += ", Berlin";
                    if (!query.toLowerCase().includes("germany")) query += ", Germany";

                    const res = await fetch(`https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(query)}&format=json&limit=1`, {
                        headers: { 'User-Agent': 'BellaBona-IntelliRoute/2.0' }
                    });
                    const data = await res.json();

                    if (data && data.length > 0) {
                        const coords = { lat: parseFloat(data[0].lat), lng: parseFloat(data[0].lon) };

                        // Cache the result in Firebase
                        try {
                            await setDoc(doc(db, "geocode_cache", cacheKey), {
                                ...coords,
                                address: address,
                                companyName: companyName,
                                lastUpdated: new Date().toISOString()
                            });
                            console.log("‚úÖ Geocoded and cached:", cacheKey, coords);
                        } catch (e) {
                            console.warn("Cache save failed:", e);
                        }

                        return coords;
                    }
                } catch (e) {
                    console.error("Geocoding failed for:", cacheKey, e);
                }

                return null;
            };

            const haversine = (lat1, lon1, lat2, lon2) => {
                const R = 6371; // km
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLon = (lon2 - lon1) * Math.PI / 180;
                const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLon / 2) * Math.sin(dLon / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                return R * c;
            };

            const calculateInitialTours = async (orders) => {
                setLoading(true);
                const newTours = DRIVERS.map(d => ({ driverId: d.id, driverName: d.name, orders: [] }));

                const unassigned = [];
                const assignedIds = new Set();

                // Geocode orders using Registry as source of truth
                let processedCount = 0;
                const totalOrders = orders.length;

                for (const order of orders) {
                    processedCount++;
                    // Update progress every 5 orders or so to avoid too many re-renders
                    if (processedCount % 5 === 0 || processedCount === totalOrders) {
                        setUploadProgress(Math.floor((processedCount / totalOrders) * 80)); // Geocoding is 80% of the work
                    }

                    if (!order.lat || !order.lng) {
                        // Smart branch matching: "Nike - Mitte" should match "Nike (powered by CBRE)" in Registry
                        let registryEntry = registryRef.current[order.name];

                        // If exact match not found, try fuzzy matching for branches
                        if (!registryEntry) {
                            const baseName = order.name.split('-')[0].trim();
                            const matchingKey = Object.keys(registryRef.current).find(key =>
                                key.toLowerCase().includes(baseName.toLowerCase()) ||
                                baseName.toLowerCase().includes(key.split(/[-()]/)[0].trim().toLowerCase())
                            );
                            if (matchingKey) {
                                registryEntry = registryRef.current[matchingKey];
                                console.log(`üîó Branch matched: "${order.name}" ‚Üí "${matchingKey}"`);
                            }
                        }

                        if (registryEntry && registryEntry.address) {
                            // Use Registry address
                            const coords = await geocodeAddress(registryEntry.address, order.name);
                            if (coords) {
                                order.lat = coords.lat;
                                order.lng = coords.lng;
                                order.address = registryEntry.address;
                                if (registryEntry.eatingTime) {
                                    order.registryEatingTime = registryEntry.eatingTime;
                                }
                            }
                        } else if (order.address) {
                            // Fall back to JSON address if not in Registry
                            console.warn("‚ö†Ô∏è Company not in Registry:", order.name, "- using JSON address");
                            const coords = await geocodeAddress(order.address, order.name);
                            if (coords) {
                                order.lat = coords.lat;
                                order.lng = coords.lng;
                            }
                        } else {
                            // Last resort: geocode company name
                            console.warn("‚ö†Ô∏è No address found for:", order.name, "- geocoding company name");
                            const coords = await geocodeAddress("", order.name);
                            if (coords) {
                                order.lat = coords.lat;
                                order.lng = coords.lng;
                            }
                        }
                    }

                    // Calculate Urgency for Assignment
                    // Note: registryEatingTime might have been set in geocoding block above
                    const [h, m] = (order.deliverySlotEnd || "12:00").split(':').map(Number);
                    let dL = (h * 60 + m) || 720;
                    if (order.registryEatingTime) {
                        const [eh, em] = order.registryEatingTime.split(':').map(Number);
                        dL = eh * 60 + em;
                    }
                    order.deadlineMinutes = dL;

                    let assigned = false;
                    for (const [driverId, keywords] of Object.entries(GOLDEN_PLAN)) {
                        // Only assign to drivers who are NOT explicitly OFF
                        if (driverAvailability[driverId] === false) continue;

                        // SAFEGUARD: Don't overload Golden Plan drivers (e.g. Samir)
                        // If they are over capacity (Strict), leave for Zone Distribution
                        const tour = newTours.find(t => t.driverId === driverId);
                        const driver = DRIVERS.find(d => d.id === driverId);
                        if (tour && tour.orders.length >= driver.capacity) continue;

                        const match = keywords.some(k => order.name.toLowerCase().includes(k.toLowerCase()));
                        if (match) {
                            if (tour) {
                                tour.orders.push(order);
                                assignedIds.add(order.id);
                                assigned = true;
                                break;
                            }
                        }
                    }
                    if (!assigned) unassigned.push(order);
                }

                // --- CLUSTER-FIRST STRATEGY: GROUP THEN ASSIGN ---

                // 1. Group Orders into Physical Stops (Locations)
                // This ensures multiple orders for one building are assigned to the SAME driver as a single unit.
                const stops = [];
                unassigned.forEach(order => {
                    if (!order.lat || !order.lng) {
                        stops.push({ lat: null, lng: null, address: order.address, items: [order] });
                        return;
                    }

                    // Try to find existing close stop (< 50m)
                    let match = stops.find(s => {
                        if (s.lat && s.lng) return haversine(s.lat, s.lng, order.lat, order.lng) < 0.05;
                        return false;
                    });

                    if (match) {
                        match.items.push(order);
                    } else {
                        stops.push({ lat: order.lat, lng: order.lng, address: order.address, items: [order] });
                    }
                });

                // 2. Prepare Assignment Candidates
                // Evaluate distance from each Stop to each Active Driver's Zone Anchor
                const candidates = [];
                const activeDriversList = DRIVERS.filter(d => d.id === 'josef' || driverAvailability[d.id] !== false);

                // Track remaining capacity (Default 15 if not specified)
                const driverCapacities = {};
                activeDriversList.forEach(d => driverCapacities[d.id] = (d.capacity || 15));

                stops.forEach(stop => {
                    activeDriversList.forEach(driver => {
                        let dist = 9999;
                        if (stop.lat && stop.lng) {
                            dist = haversine(stop.lat, stop.lng, driver.zoneAnchor.lat, driver.zoneAnchor.lng);
                        }
                        candidates.push({ stop, driverId: driver.id, dist });
                    });
                });

                // 3. Greedy Global Assignment
                // Sort by distance (Ascending) -> Closest matches get priority
                candidates.sort((a, b) => a.dist - b.dist);

                const assignedStops = new Set();
                const driverStopMap = {};
                activeDriversList.forEach(d => driverStopMap[d.id] = []);

                const driverUrgentCount = {};
                activeDriversList.forEach(d => driverUrgentCount[d.id] = 0);

                candidates.forEach(cand => {
                    if (assignedStops.has(cand.stop)) return; // Already assigned

                    let cap = driverCapacities[cand.driverId];
                    const demand = cand.stop.items.length; // Count boxes

                    const deadline = cand.stop.items[0].deadlineMinutes || 9999;
                    const isUrgent = (deadline <= 750); // 12:30 or earlier

                    // CORE ZONE PRIORITY: "Divide Area First"
                    // If < 3km, take it (Ignore limits)
                    const isCore = (cand.dist < 3.0);

                    if (isUrgent && driverUrgentCount[cand.driverId] >= 8 && !isCore) return;
                    if (cap < demand && !isCore) return;

                    driverStopMap[cand.driverId].push(cand.stop);
                    driverCapacities[cand.driverId] -= demand;
                    assignedStops.add(cand.stop);
                    if (isUrgent) driverUrgentCount[cand.driverId]++;
                });

                // 4. Handle Overload (Force Assign Leftovers to Closest Driver)
                stops.forEach(stop => {
                    if (!assignedStops.has(stop)) {
                        let bestDriverId = activeDriversList[0].id; // Fallback
                        let minDist = Infinity;

                        activeDriversList.forEach(d => {
                            let dist = 9999;
                            if (stop.lat && stop.lng) dist = haversine(stop.lat, stop.lng, d.zoneAnchor.lat, d.zoneAnchor.lng);
                            if (dist < minDist) {
                                minDist = dist;
                                bestDriverId = d.id;
                            }
                        });

                        // Force Push
                        driverStopMap[bestDriverId].push(stop);
                        assignedStops.add(stop);
                    }
                });

                // 5. Populate Tours and Mark Assigned
                activeDriversList.forEach(driver => {
                    const tour = newTours.find(t => t.driverId === driver.id);
                    if (tour) {
                        const flatOrders = driverStopMap[driver.id].flatMap(s => s.items);
                        tour.orders.push(...flatOrders);
                        flatOrders.forEach(o => assignedIds.add(o.id));
                    }
                });

                // OPTIMIZE ROUTES: Time-Based Nearest Neighbor
                // Auto-Adjust Departure Time if orders are early
                const DEPARTURE_TIME = 10 * 60; // 10:00 AM departure as requested
                const AVG_SPEED_KM_PER_MIN = 1 / 3; // 20 km/h average
                const STOP_TIME_MINUTES = 5;

                newTours.forEach(tour => {
                    if (tour.orders.length === 0) return;

                    // Parse delivery times and add urgency score
                    tour.orders.forEach(order => {
                        const [hours, mins] = (order.deliverySlotEnd || "12:00").split(':').map(Number);
                        let deadline = (hours * 60 + mins) || 720;

                        // CRITICAL: Use Registry Eating Time as the REAL Deadline
                        // If company eats at 11:30, we MUST deliver by 11:30.
                        if (order.registryEatingTime) {
                            const [eh, em] = order.registryEatingTime.split(':').map(Number);
                            const eatingTime = eh * 60 + em;
                            // Reset deadline to Eating Time if it's cleaner/stricter
                            deadline = eatingTime;
                            order.eatingTimeMinutes = eatingTime;
                        } else {
                            order.eatingTimeMinutes = deadline + 30;
                        }
                        order.deadlineMinutes = deadline;
                    });

                    // Debug Log for Users
                    if (tour.orders.length > 0) {
                        console.log(`[Driver ${tour.driverName}] Orders: ${tour.orders.length}. Earliest Deadline: ${Math.min(...tour.orders.map(o => o.deadlineMinutes))}`);
                    }

                    const optimized = [];
                    let currentPos = POTSDAM_KITCHEN;
                    let currentTime = DEPARTURE_TIME;
                    const pool = [...tour.orders];

                    while (pool.length > 0) {
                        // 1. Identify Critical Time Window
                        // Find the absolute earliest deadline among remaining orders
                        let minDeadline = Infinity;
                        pool.forEach(o => {
                            if (o.deadlineMinutes < minDeadline) minDeadline = o.deadlineMinutes;
                        });

                        // 2. Filter Candidates: "Basic Brain" Logic
                        // Consider ONLY orders that are due within 30 minutes of the earliest deadline.
                        // This prevents delivering a 13:00 order (next door) when an 11:30 order is waiting 5km away.
                        const TIME_BUCKET = 15;
                        const candidates = pool.filter(o => o.deadlineMinutes <= minDeadline + TIME_BUCKET);

                        // 3. Find Nearest Neighbor among Candidates
                        // "Then find which one is nearest from last stop"
                        let bestIdx = -1;
                        let minDist = Infinity;

                        pool.forEach((o, idx) => {
                            // Only consider candidates in the bucket
                            if (candidates.includes(o)) {
                                let dist = 9999;
                                if (currentPos.lat && o.lat && currentPos.lng && o.lng) {
                                    dist = haversine(currentPos.lat, currentPos.lng, o.lat, o.lng);
                                }

                                if (dist < minDist) {
                                    minDist = dist;
                                    bestIdx = idx;
                                }
                            }
                        });

                        if (bestIdx === -1) bestIdx = 0;

                        const nextStop = pool.splice(bestIdx, 1)[0];

                        // --- GROUPING LOGIC ---
                        const siblings = [];
                        for (let i = pool.length - 1; i >= 0; i--) {
                            const candidate = pool[i];
                            let isSame = false;
                            if (nextStop.lat && nextStop.lng && candidate.lat && candidate.lng) {
                                if (haversine(nextStop.lat, nextStop.lng, candidate.lat, candidate.lng) < 0.05) isSame = true;
                            } else if (nextStop.address === candidate.address && nextStop.address) isSame = true;

                            if (isSame) siblings.push(pool.splice(i, 1)[0]);
                        }

                        // Update current time and position
                        if (nextStop.lat && nextStop.lng) {
                            const dist = haversine(currentPos.lat, currentPos.lng, nextStop.lat, nextStop.lng);
                            const travel = dist / AVG_SPEED_KM_PER_MIN;
                            currentTime += travel + STOP_TIME_MINUTES;
                            currentPos = { lat: nextStop.lat, lng: nextStop.lng };
                        } else {
                            currentTime += 10;
                        }

                        nextStop.estimatedArrival = currentTime;
                        optimized.push(nextStop);

                        // Process Siblings (Quick Drop)
                        siblings.forEach(sib => {
                            currentTime += 1; // 1 min extra per box
                            sib.estimatedArrival = currentTime;
                            optimized.push(sib);
                        });
                    }
                    tour.orders = optimized;
                });

                // --- SIMULATION CHECK ---
                console.group("üöÄ Route Simulation Report");
                let lateCount = 0;
                newTours.forEach(t => {
                    if (t.orders.length > 0) console.log(`DRIVER: ${t.driverName} (${t.orders.length} stops)`);
                    let time = DEPARTURE_TIME;
                    let lastPos = POTSDAM_KITCHEN;
                    t.orders.forEach(o => {
                        if (o.lat && o.lng) {
                            const dist = haversine(lastPos.lat, lastPos.lng, o.lat, o.lng);
                            const travel = dist / AVG_SPEED_KM_PER_MIN;
                            const stopTime = dist < 0.05 ? 1 : STOP_TIME_MINUTES; // Smart Stop Time
                            time += travel + stopTime;
                            lastPos = { lat: o.lat, lng: o.lng };
                        } else {
                            time += 15;
                        }

                        const timeStr = `${Math.floor(time / 60).toString().padStart(2, '0')}:${(Math.floor(time) % 60).toString().padStart(2, '0')}`;
                        const isLate = (o.deadlineMinutes && time > o.deadlineMinutes);
                        if (isLate) {
                            lateCount++;
                            console.error(`  ‚ö†Ô∏è LATE: ${o.name} (Arr: ${timeStr} | Due: ${o.deliverySlotEnd})`);
                        } else {
                            console.log(`  ‚úÖ OK: ${o.name} (Arr: ${timeStr} | Due: ${o.deliverySlotEnd})`);
                        }
                        o.estimatedArrival = time;
                    });
                });
                if (lateCount === 0) console.log("%c‚úÖ ALL ON TIME!", "color: green; font-weight: bold; font-size: 14px;");
                else console.error(`‚ùå ${lateCount} LATE DELIVERIES DETECTED`);
                console.groupEnd();


                setTours(newTours);
                setLoading(false);
                return newTours;
            };
            // Modal Component
            // Modal Component
            const UploadModal = () => {
                const [text, setText] = useState("");
                return (
                    <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4">
                        <div className="bg-slate-900 border border-slate-700 p-6 rounded-xl w-full max-w-2xl shadow-2xl">
                            <h2 className="text-xl font-bold text-white mb-2">Upload Daily Plan</h2>
                            <p className="text-slate-400 text-sm mb-2">Paste your daily orders JSON here. This will generate routes and save the plan to the cloud.</p>
                            <div className="bg-indigo-900/30 border border-indigo-700 rounded-lg px-4 py-2 mb-4">
                                <span className="text-xs text-indigo-300 font-bold">üìÖ Saving to: {selectedDate}</span>
                            </div>

                            {uploadProgress > 0 && uploadProgress < 100 ? (
                                <div className="mb-4">
                                    <div className="flex justify-between text-xs text-slate-300 mb-1">
                                        <span>Processing geography & routes...</span>
                                        <span>{uploadProgress}%</span>
                                    </div>
                                    <div className="w-full bg-slate-800 rounded-full h-2.5">
                                        <div className="bg-indigo-600 h-2.5 rounded-full transition-all duration-300" style={{ width: `${uploadProgress}%` }}></div>
                                    </div>
                                </div>
                            ) : (
                                <textarea
                                    className="w-full h-64 bg-slate-950 border border-slate-800 rounded p-4 text-xs font-mono text-slate-300 focus:outline-none focus:border-indigo-500"
                                    placeholder='[ { "name": "Company A", ... }, ... ]'
                                    value={text}
                                    onChange={(e) => setText(e.target.value)}
                                />
                            )}

                            <div className="flex justify-end gap-3 mt-4">
                                <button onClick={() => setShowUpload(false)} className="px-4 py-2 rounded text-slate-400 font-bold hover:text-white transition-colors">Cancel</button>
                                <button
                                    onClick={() => processJsonData(text)}
                                    disabled={uploadProgress > 0 && uploadProgress < 100}
                                    className={`px-6 py-2 rounded font-bold transition-colors ${uploadProgress > 0 ? 'bg-slate-700 text-slate-400 cursor-not-allowed' : 'bg-indigo-600 hover:bg-indigo-500 text-white'}`}
                                >
                                    {uploadProgress > 0 && uploadProgress < 100 ? 'Processing...' : 'Process & Save Plan'}
                                </button>
                            </div>
                        </div>
                    </div>
                );
            };

            // Calendar Modal Component
            const CalendarModal = () => {
                const [month, setMonth] = useState(new Date(selectedDate));
                const daysInMonth = new Date(month.getFullYear(), month.getMonth() + 1, 0).getDate();
                const firstDay = new Date(month.getFullYear(), month.getMonth(), 1).getDay();
                const days = Array.from({ length: daysInMonth }, (_, i) => i + 1);
                const blanks = Array.from({ length: firstDay === 0 ? 6 : firstDay - 1 });

                const selectDate = (day) => {
                    const yyyy = month.getFullYear();
                    const mm = String(month.getMonth() + 1).padStart(2, '0');
                    const dd = String(day).padStart(2, '0');
                    setSelectedDate(`${yyyy}-${mm}-${dd}`);
                    setShowCalendar(false);
                };

                return (
                    <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4">
                        <div className="bg-slate-900 border border-slate-700 p-6 rounded-xl w-full max-w-sm shadow-2xl">
                            <div className="flex justify-between items-center mb-4">
                                <h2 className="text-lg font-bold text-white">Select Date</h2>
                                <button onClick={() => setShowCalendar(false)} className="text-slate-400 hover:text-white">‚úï</button>
                            </div>
                            <div className="flex justify-between mb-4">
                                <button onClick={() => setMonth(new Date(month.setMonth(month.getMonth() - 1)))} className="text-indigo-400 font-bold">&lt;</button>
                                <span className="font-bold">{month.toLocaleString('default', { month: 'long', year: 'numeric' })}</span>
                                <button onClick={() => setMonth(new Date(month.setMonth(month.getMonth() + 1)))} className="text-indigo-400 font-bold">&gt;</button>
                            </div>
                            <div className="grid grid-cols-7 gap-1 text-center mb-2">
                                {['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'].map(d => <div key={d} className="text-xs text-slate-500">{d}</div>)}
                            </div>
                            <div className="grid grid-cols-7 gap-1">
                                {blanks.map((_, i) => <div key={i}></div>)}
                                {days.map(d => (
                                    <button
                                        key={d}
                                        onClick={() => selectDate(d)}
                                        className={`p-2 text-sm rounded hover:bg-indigo-900 ${selectedDate === `${month.getFullYear()}-${String(month.getMonth() + 1).padStart(2, '0')}-${String(d).padStart(2, '0')}`
                                            ? 'bg-indigo-600 text-white font-bold'
                                            : 'text-slate-300'
                                            }`}
                                    >
                                        {d}
                                    </button>
                                ))}
                            </div>
                        </div>
                    </div>
                );
            };

            // Recovery Modal Component
            const RecoveryModal = ({ onClose }) => {
                const [pendingCompanies, setPendingCompanies] = useState([]);
                const [loading, setRecoveryLoading] = useState(true);

                useEffect(() => {
                    const fetchPending = async () => {
                        setRecoveryLoading(true);
                        const today = new Date(selectedDate);
                        const recentPlans = [];
                        const companiesWithBoxes = new Map(); // Store company -> date it had boxes

                        // Scan last 3 days
                        for (let i = 1; i <= 3; i++) {
                            const d = new Date(today);
                            d.setDate(today.getDate() - i);
                            const dateStr = d.toISOString().split('T')[0];
                            try {
                                const docSnap = await getDoc(doc(db, "daily_plans", dateStr));
                                if (docSnap.exists()) {
                                    const plan = docSnap.data();
                                    const orders = plan.tours ? plan.tours.flatMap(t => t.orders) : [];
                                    orders.forEach(o => {
                                        // We record the LATEST date they ordered
                                        if (!companiesWithBoxes.has(o.name)) {
                                            companiesWithBoxes.set(o.name, dateStr);
                                        }
                                    });
                                }
                            } catch (e) { console.error(e); }
                        }

                        // Get Today's Companies to exclude
                        const todaysCompanies = new Set();
                        tours.forEach(t => t.orders.forEach(o => todaysCompanies.add(o.name)));

                        // Diff
                        const pending = [];
                        companiesWithBoxes.forEach((date, name) => {
                            // If they have boxes from recent days BUT are not ordering today
                            // Then they likely still have empty boxes to pick up
                            if (!todaysCompanies.has(name)) {
                                pending.push({ name, date });
                            }
                        });

                        setPendingCompanies(pending);
                        setRecoveryLoading(false);
                    };
                    fetchPending();
                }, []);

                return (
                    <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4">
                        <div className="bg-slate-900 border border-slate-700 p-6 rounded-xl w-full max-w-lg shadow-2xl overflow-hidden flex flex-col max-h-[80vh]">
                            <div className="flex justify-between items-center mb-4">
                                <h2 className="text-xl font-bold text-white flex items-center gap-2">üì¶ Pending Recovery <span className="text-xs bg-indigo-900 text-indigo-300 px-2 py-1 rounded-full">{pendingCompanies.length}</span></h2>
                                <button onClick={onClose} className="text-slate-400 hover:text-white">‚úï</button>
                            </div>

                            <p className="text-slate-400 text-xs mb-4">
                                These companies ordered in the last 3 days but are <b>not</b> in today's plan. They likely have empty boxes waiting.
                            </p>

                            {loading ? (
                                <div className="text-center py-8 text-indigo-400">Scanning history...</div>
                            ) : (
                                <div className="overflow-y-auto flex-1 space-y-2 pr-2">
                                    {pendingCompanies.length === 0 ? (
                                        <div className="text-center py-8 text-slate-500">‚úÖ All clean! No pending pickups found.</div>
                                    ) : (
                                        pendingCompanies.map((c, idx) => (
                                            <div key={idx} className="bg-slate-800 p-3 rounded flex justify-between items-center border border-slate-700">
                                                <div>
                                                    <div className="font-bold text-sm text-white">{c.name}</div>
                                                    <div className="text-[10px] text-slate-400">Box from: {c.date}</div>
                                                </div>
                                                <span className="text-xs bg-orange-900/50 text-orange-300 px-2 py-1 rounded border border-orange-900">Pending</span>
                                            </div>
                                        ))
                                    )}
                                </div>
                            )}

                            <div className="mt-4 text-right">
                                <button onClick={onClose} className="px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded text-sm font-bold transition-colors">Close</button>
                            </div>
                        </div>
                    </div>
                );
            };

            // Driver Availability Dropdown Modal
            const DriverAvailabilityModal = () => {
                return (
                    <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4" onClick={() => setShowDriverDropdown(false)}>
                        <div className="bg-slate-900 border border-slate-700 p-6 rounded-xl shadow-2xl max-w-md" onClick={(e) => e.stopPropagation()}>
                            <h3 className="text-white font-bold mb-4 text-lg">Driver Availability - {selectedDate}</h3>
                            <div className="space-y-2 max-h-96 overflow-y-auto">
                                {DRIVERS.map(driver => {
                                    const isOn = driverAvailability[driver.id] !== false;
                                    return (
                                        <div key={driver.id} className="flex items-center justify-between bg-slate-800 p-3 rounded border border-slate-700">
                                            <div className="flex items-center gap-3">
                                                <div className="w-4 h-4 rounded-full" style={{ backgroundColor: driver.color }} />
                                                <span className="text-white font-medium">{driver.name}</span>
                                            </div>
                                            <button
                                                onClick={() => toggleDriverAvailability(driver.id)}
                                                className={`px-4 py-2 rounded font-bold text-xs transition-all ${isOn
                                                    ? 'bg-emerald-600 text-white hover:bg-emerald-500'
                                                    : 'bg-slate-700 text-slate-400 hover:bg-slate-600'
                                                    }`}
                                            >
                                                {isOn ? '‚úì ON' : '‚úó OFF'}
                                            </button>
                                        </div>
                                    );
                                })}
                            </div>
                            <button
                                onClick={() => setShowDriverDropdown(false)}
                                className="mt-4 w-full bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-4 rounded transition-colors"
                            >
                                Done
                            </button>
                        </div>
                    </div>
                );
            };

            const handleFileUpload = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => processJsonData(event.target.result);
                reader.readAsText(file);
            };

            const exportToCSV = () => {
                let csv = "Driver,Stop Number,Company,Address,Postal Code,Boxes,Dishes\n";
                tours.forEach(t => {
                    t.orders.forEach((o, i) => {
                        csv += `${t.driverName},${i + 1},"${o.name}","${o.address}",${o.postCode},${o.boxes},${o.dishes || 0}\n`;
                    });
                });
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `routing_schedule_${new Date().toISOString().split('T')[0]}.csv`;
                a.click();
            };

            return (
                <div className="flex flex-col h-screen text-slate-200 font-sans">
                    {/* Header */}
                    <div className="h-14 bg-slate-900 border-b border-slate-700 flex items-center justify-between px-4">
                        <div className="flex items-center gap-4">
                            <h1 className="text-xl font-bold bg-gradient-to-r from-indigo-400 to-cyan-400 bg-clip-text text-transparent">
                                BellaBona Routing
                            </h1>
                            <div className="flex bg-slate-800 rounded-lg p-1 gap-1">
                                <button
                                    onClick={() => setView('grid')}
                                    className={`px-3 py-1 rounded text-xs font-bold transition-all ${view === 'grid' ? 'bg-indigo-600 text-white shadow-lg' : 'text-slate-400 hover:text-white'}`}
                                >
                                    GRID
                                </button>
                                <button
                                    onClick={() => setView('registry')}
                                    className={`px-3 py-1 rounded text-xs font-bold transition-all ${view === 'registry' ? 'bg-indigo-600 text-white shadow-lg' : 'text-slate-400 hover:text-white'}`}
                                >
                                    REGISTRY
                                </button>
                            </div>
                        </div>

                        <div className="flex items-center gap-3">
                            <div className="flex items-center bg-slate-800 rounded px-3 py-1.5 border border-slate-700 text-sm gap-2">
                                <span className="text-slate-400">üìÖ</span>
                                <span className="font-mono font-bold">{selectedDate}</span>
                                <button onClick={() => setShowCalendar(true)} className="ml-2 text-xs bg-indigo-900/50 hover:bg-indigo-900 text-indigo-300 px-2 py-0.5 rounded transition-colors">
                                    CHANGE
                                </button>
                            </div>

                            <button
                                onClick={() => setShowRecovery(true)}
                                className="bg-orange-900/30 border border-orange-700/50 hover:bg-orange-900/50 text-orange-200 px-3 py-1.5 rounded text-sm font-bold transition-all flex items-center gap-2"
                            >
                                <span>üì¶ RECOVERY</span>
                            </button>

                            <button
                                onClick={() => setShowDriverDropdown(true)}
                                className="bg-slate-800 hover:bg-slate-700 border border-slate-600 text-slate-300 px-3 py-1.5 rounded text-sm font-bold transition-all flex items-center gap-2"
                            >
                                <span>üöó DRIVERS</span>
                            </button>

                            <button
                                onClick={() => {
                                    if (confirm("Re-optimize all routes with Cluster-First Logic?")) {
                                        setShowUpload(true);
                                        setUploadProgress(5);
                                        const allOrders = tours.flatMap(t => t.orders);
                                        setTimeout(async () => {
                                            await calculateInitialTours(allOrders);
                                            setUploadProgress(100);
                                            setTimeout(() => setShowUpload(false), 500);
                                        }, 100);
                                    }
                                }}
                                className="bg-indigo-600 hover:bg-indigo-500 text-white px-3 py-1.5 rounded text-sm font-bold shadow-lg shadow-indigo-500/50 transition-all flex items-center gap-2"
                                title="Apply Zone & Grouping Optimization"
                            >
                                <span>‚ö° RE-ROUTE</span>
                            </button>

                            <button
                                onClick={() => setShowUpload(true)}
                                className="bg-indigo-600 hover:bg-indigo-500 text-white px-3 py-1.5 rounded text-sm font-bold shadow-lg shadow-indigo-900/20 transition-all flex items-center gap-2"
                            >
                                <span>‚òÅÔ∏è UPLOAD PLAN</span>
                            </button>
                            <button onClick={exportToCSV} className="bg-emerald-600 hover:bg-emerald-500 text-white text-xs font-bold px-4 py-2 rounded shadow transition-all flex items-center gap-2">
                                <span>DOWNLOAD CSV</span>
                            </button>
                        </div>
                    </div>

                    {/* MODALS */}
                    {showUpload && <UploadModal />}
                    {showCalendar && <CalendarModal />}
                    {showDriverDropdown && <DriverAvailabilityModal />}
                    {showRecovery && <RecoveryModal onClose={() => setShowRecovery(false)} />}

                    <main className="flex-1 flex overflow-hidden relative">
                        {view === 'grid' && (
                            <div className="w-full h-full flex flex-col">
                                <div style={{ height: `${gridHeight}%` }} className="border-b border-slate-700 relative group">
                                    <RouteMap tours={tours.filter(t => driverAvailability[t.driverId] !== false)} height={600} onOrderMove={handleOrderMove} onGeocodeUpdate={(id, lat, lng) => {
                                        setTours(prev => prev.map(t => ({
                                            ...t,
                                            orders: t.orders.map(o => o.id === id ? { ...o, lat, lng } : o)
                                        })));
                                    }} />
                                    <div className="absolute top-4 left-4 bg-slate-900/90 text-white p-3 rounded border border-white/10 backdrop-blur text-xs z-50 pointer-events-none">
                                        <div className="font-bold text-slate-400 mb-1">TOTAL ORDERS</div>
                                        <div className="text-2xl font-black">{tours.filter(t => driverAvailability[t.driverId] !== false).reduce((acc, t) => acc + t.orders.length, 0)}</div>
                                    </div>
                                    {/* Resize Handle */}
                                    <div
                                        className="absolute bottom-0 left-0 right-0 h-2 bg-indigo-600/20 hover:bg-indigo-600/50 cursor-ns-resize group-hover:opacity-100 opacity-0 transition-opacity"
                                        onMouseDown={(e) => {
                                            const startY = e.clientY;
                                            const startHeight = gridHeight;
                                            const onMove = (e) => {
                                                const delta = ((e.clientY - startY) / window.innerHeight) * 100;
                                                setGridHeight(Math.max(20, Math.min(80, startHeight + delta)));
                                            };
                                            const onUp = () => {
                                                document.removeEventListener('mousemove', onMove);
                                                document.removeEventListener('mouseup', onUp);
                                            };
                                            document.addEventListener('mousemove', onMove);
                                            document.addEventListener('mouseup', onUp);
                                        }}
                                    />
                                </div>
                                <div style={{ height: `${100 - gridHeight}%` }} className="bg-slate-900 p-2">
                                    <GridView
                                        tours={tours.filter(t => driverAvailability[t.driverId] !== false)}
                                        setTours={setTours}
                                        packerNames={packerNames}
                                        setPackerNames={setPackerNames}
                                        onSave={saveDailyPlan}
                                        registry={registry}
                                    />
                                </div>
                            </div>
                        )}

                        {view === 'registry' && <div className="w-full h-full overflow-y-auto"><RegistryView registry={registry} /></div>}
                    </main>
                </div>
            );
        }

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>