<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BellaBona IntelliRoute - Excel Master</title>

    <!-- External Utilities -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;900&display=swap"
        rel="stylesheet">
    <link href="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.css" rel="stylesheet" />

    <!-- Babel & React/Firebase from CDN -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: #0f172a;
            color: #e2e8f0;
        }

        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #0f172a;
        }

        ::-webkit-scrollbar-thumb {
            background: #334155;
            border-radius: 4px;
        }

        .map-dark-mode canvas {
            filter: invert(100%) hue-rotate(180deg) brightness(95%) contrast(90%);
        }

        .scrollbar-hide::-webkit-scrollbar {
            display: none;
        }

        .excel-grid th,
        .excel-grid td {
            border: 1px solid #334155;
            padding: 4px 8px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .excel-grid th {
            background: #1e293b;
            color: #94a3b8;
            font-weight: bold;
            text-align: left;
        }

        .excel-grid tr:hover {
            background: #1e293b;
        }

        .draggable-item {
            cursor: grab;
        }

        .draggable-item:active {
            cursor: grabbing;
            background: #3730a3;
        }

        .grid-col-driver {
            min-width: 140px;
            border-right: 1px solid #334155;
        }
    </style>

    <!-- Error Handler -->
    <script>
        window.onerror = function (msg, url, line, col, error) {
            document.body.innerHTML = `
                <div style="background:#0f172a;color:#ef4444;padding:40px;font-family:monospace;height:100vh;display:flex;flex-col;justify-content:center;align-items:center;">
                    <div style="max-width:800px;">
                        <h1 style="font-size:24px;margin-bottom:20px;">SYSTEM CRITICAL ERROR</h1>
                        <p style="background:#1e293b;padding:20px;border-radius:10px;border:1px solid #334155;">${msg}</p>
                        <p style="color:#64748b;margin-top:10px;">${url}:${line}:${col}</p>
                    </div>
                </div>
            `;
            console.error("Critical Error:", error);
            return false;
        };
    </script>

    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "@google/generative-ai": "https://esm.sh/@google/generative-ai@0.21.0",
        "firebase/app": "https://www.gstatic.com/firebasejs/10.13.0/firebase-app.js",
        "firebase/firestore": "https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore.js",
        "maplibre-gl": "https://esm.sh/maplibre-gl@4.7.1"
      }
    }
    </script>

    <!-- INJECTED ORDERS DATA (from User Desktop) -->
    <script src="orders_data.js"></script>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel" data-presets="react" data-type="module">
        import React, { useState, useEffect, useMemo, useRef } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as firebaseApp from 'firebase/app';
        import {
            getFirestore,
            initializeFirestore,
            persistentLocalCache,
            persistentMultipleTabManager,
            collection,
            doc,
            setDoc,
            getDoc,
            onSnapshot,
            writeBatch
        } from 'firebase/firestore';
        import { GoogleGenerativeAI } from '@google/generative-ai';
        import { Map as MapLibreMap, NavigationControl, AttributionControl, Marker, Popup, LngLatBounds } from 'maplibre-gl';

        console.log("App initializing...");

        // --- CONSTANTS ---
        const POTSDAM_KITCHEN = { lat: 52.3906, lng: 13.0645, address: "Friedrich-Engels-Stra√üe 24, 14473 Potsdam" };

        const DRIVERS = [
            { id: 'samir', name: 'Samir', level: 1, capacity: 16, isActive: true, color: '#f59e0b' },
            { id: 'ali1', name: 'Ali 1', level: 1, capacity: 12, isActive: true, color: '#ec4899' },
            { id: 'ali2', name: 'Ali 2', level: 1, capacity: 10, isActive: true, color: '#ff4500' }, // OrangeRed
            { id: 'ali3', name: 'Ali 3', level: 2, capacity: 12, isActive: true, color: '#32cd32' }, // LimeGreen
            { id: 'ali4', name: 'Ali 4', level: 2, capacity: 12, isActive: true, color: '#00ced1' }, // DarkTurquoise
            { id: 'ankush', name: 'Ankush', level: 3, capacity: 12, isActive: true, color: '#9400d3' }, // DarkViolet
            { id: 'tasnim', name: 'Tasnim', level: 4, capacity: 16, isActive: true, color: '#ff00ff' }, // Magenta
            { id: 'packtor1', name: 'Packator 1', level: 4, capacity: 10, isActive: true, color: '#ffd700' }, // Gold
            { id: 'packtor2', name: 'Packator 2', level: 4, capacity: 10, isActive: true, color: '#dc143c' }, // Crimson
            { id: 'packtor3', name: 'Packator 3', level: 4, capacity: 10, isActive: true, color: '#adff2f' }, // GreenYellow
            { id: 'harsh', name: 'Harsh', level: 2, capacity: 12, isActive: true, color: '#4169e1' }, // RoyalBlue
            { id: 'josef', name: 'Josef', level: 2, capacity: 12, isActive: true, color: '#000080' }, // Navy
        ];

        const GOLDEN_PLAN = {
            'samir': ['Ingenierburo', 'Shiftmove', 'Nike', 'King', 'Momox', 'Love', 'Lovehoney', 'Wohnung', 'Team Viewer', 'TeamViewer', 'IFX'],
            'ali1': ['Probio', 'Isi', 'Mektec', 'Pen', 'PenCef', 'Expert', 'Aignostic', 'Koppla'],
            'tasnim': ['Hilton', 'alteos', 'Ritual', 'teufel', 'Lautsprecher', 'Degewo-Kurfurstendam', 'Degewo-Kurf√ºrstenstr', 'Kws', 'Almedia', 'Gsport-YUME', 'nexnet', 'unzer', 'Semrush', 'Adyen', 'Tui', 'Office'],
            'packtor1': ['Core', 'Affinidi', 'Bitpanda', 'Parloa', 'Personio', 'Verve'],
            'ali2': ['Getranke', 'Getr√§nke', 'Joachim', 'Gottschalk', 'Liquid', 'Giantx', 'Heart', 'Berlin Heart', 'Tib', 'Omicron'],
            'josef': ['Viessmann', 'Digital', 'Pomelo', 'Gentlemates', 'Leapsome', 'Degewo-Brunnen', 'Bonial', 'Cognita', 'BCL', 'Charles'],
            'packtor2': ['Bahnhofstr', 'Kayak', 'Omio', 'Mehrower'],
            'ali3': ['Tam', 'Byrd', 'Taxfix', 'OnCloud', 'On Cloud', 'Beyvers', 'Ellabarowsky', 'Ella-Barowsky']
        };

        const firebaseConfig = {
            apiKey: "AIzaSyBCljwsTQ-PHm20VP-i8VByNrRwVFgMl5I",
            authDomain: "routing-4aab8.firebaseapp.com",
            databaseURL: "https://routing-4aab8-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "routing-4aab8",
            storageBucket: "routing-4aab8.firebasestorage.app",
            messagingSenderId: "148497920348",
            appId: "1:148497920348:web:0e14c31aa4dfde00205199"
        };
        const app = firebaseApp.initializeApp(firebaseConfig);
        const db = initializeFirestore(app, {
            ignoreUndefinedProperties: true,
            localCache: persistentLocalCache({ tabManager: persistentMultipleTabManager() })
        });

        // --- COMPONENTS ---
        const RouteMap = ({ tours, onGeocodeUpdate, height, onOrderMove }) => {
            const mapContainer = useRef(null);
            const map = useRef(null);
            const markersRef = useRef([]);
            const processingRef = useRef(new Set());

            useEffect(() => {
                window.handleMoveOrder = (orderId, driverId) => {
                    onOrderMove(orderId, driverId);
                };
            }, [onOrderMove]);

            useEffect(() => {
                if (map.current || !mapContainer.current) return;
                map.current = new MapLibreMap({
                    container: mapContainer.current,
                    style: 'https://tiles.openfreemap.org/styles/bright',
                    center: [13.405, 52.52],
                    zoom: 10,
                    attributionControl: false
                });
                window.mapInstance = map.current; // Expose for GridView interactions
                map.current.addControl(new NavigationControl(), 'top-right');

                // Kitchen Marker REMOVED
                /*
                new Marker({ color: '#ef4444', scale: 1.2 })
                    .setLngLat([POTSDAM_KITCHEN.lng, POTSDAM_KITCHEN.lat])
                    .setPopup(new Popup().setText("KITCHEN: " + POTSDAM_KITCHEN.address))
                    .addTo(map.current);
                */

                return () => { map.current?.remove(); map.current = null; };
            }, []);

            useEffect(() => {
                const queue = tours.flatMap(t => t.orders.filter(o => !o.lat && !processingRef.current.has(o.id)));
                if (queue.length === 0) return;

                const process = async () => {
                    const order = queue[0];
                    if (!order) return;
                    processingRef.current.add(order.id);

                    const query = order.address ? `${order.address}, Berlin, Germany` : `${order.name}, Berlin, Germany`;
                    try {
                        const res = await fetch(`https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(query)}&format=json&limit=1`, {
                            headers: { 'User-Agent': 'BellaBona-IntelliRoute/1.0' }
                        });
                        const data = await res.json();
                        if (data && data.length > 0) {
                            onGeocodeUpdate(order.id, parseFloat(data[0].lat), parseFloat(data[0].lon));
                        }
                    } catch (e) { }
                    setTimeout(process, 1200);
                };
                process();
            }, [tours]);

            useEffect(() => {
                map.current?.resize();
            }, [height]);

            useEffect(() => {
                if (!map.current) return;
                const m = map.current;
                markersRef.current.forEach(mk => mk.remove());
                markersRef.current = [];

                const features = [];
                const bounds = new LngLatBounds();
                // bounds.extend([POTSDAM_KITCHEN.lng, POTSDAM_KITCHEN.lat]); // Removed to focus on delivery zones

                tours.forEach(tour => {
                    const driver = DRIVERS.find(d => d.id === tour.driverId);
                    const color = driver ? driver.color : '#cbd5e1';

                    // Start route from first order, NOT kitchen
                    const coords = [];

                    tour.orders.forEach((o, idx) => {
                        if (o.lng && o.lat) {
                            coords.push([o.lng, o.lat]);
                            bounds.extend([o.lng, o.lat]);

                            const el = document.createElement('div');
                            el.innerHTML = `<div style="background:${color};width:24px;height:24px;border-radius:50%;border:2px solid white;box-shadow:0 2px 4px rgba(0,0,0,0.5);color:white;font-weight:bold;font-size:12px;display:flex;justify-content:center;align-items:center;cursor:pointer;">${idx + 1}</div>`;

                            const driverOptions = DRIVERS.map(d =>
                                `<option value="${d.id}" ${d.id === tour.driverId ? 'selected' : ''}>${d.name}</option>`
                            ).join('');

                            const popupContent = `
                                <div style="font-family:'Inter',sans-serif; min-width:200px;">
                                    <h3 style="font-weight:bold;margin-bottom:4px;">${o.name}</h3>
                                    <p style="font-size:11px;color:#64748b;margin-bottom:8px;">${o.address}</p>
                                    <div style="font-size:11px;font-weight:bold;margin-bottom:8px;">
                                        üì¶ ${o.boxes} Boxes | üçΩÔ∏è ${o.dishes || '?'} Dishes
                                    </div>
                                    <div style="background:#f1f5f9;padding:8px;border-radius:6px;">
                                        <label style="font-size:10px;font-weight:bold;display:block;margin-bottom:4px;color:#475569;">MOVE TO DRIVER:</label>
                                        <select onchange="window.handleMoveOrder('${o.id}', this.value)" style="width:100%;padding:4px;border:1px solid #cbd5e1;border-radius:4px;font-size:12px;">
                                            ${driverOptions}
                                        </select>
                                    </div>
                                </div>
                            `;

                            const marker = new Marker({ element: el })
                                .setLngLat([o.lng, o.lat])
                                .setPopup(new Popup({ maxWidth: '300px' }).setHTML(popupContent))
                                .addTo(m);
                            markersRef.current.push(marker);
                        }
                    });

                    if (coords.length > 1) {
                        features.push({
                            type: 'Feature',
                            properties: { color },
                            geometry: { type: 'LineString', coordinates: coords }
                        });
                    }
                });

                if (m.getSource('routes')) {
                    m.getSource('routes').setData({ type: 'FeatureCollection', features });
                } else if (m.isStyleLoaded()) {
                    m.addSource('routes', { type: 'geojson', data: { type: 'FeatureCollection', features } });
                    // THICK GLOW AND SOLID CORE
                    m.addLayer({ id: 'routes-glow', type: 'line', source: 'routes', paint: { 'line-color': ['get', 'color'], 'line-width': 8, 'line-opacity': 0.4, 'line-blur': 2 } });
                    m.addLayer({ id: 'routes-line', type: 'line', source: 'routes', paint: { 'line-color': ['get', 'color'], 'line-width': 3, 'line-opacity': 1 } });
                }

                if (!bounds.isEmpty()) m.fitBounds(bounds, { padding: 80 });
            }, [tours]);

            return <div ref={mapContainer} className="w-full h-full" />;
        };

        const GridView = ({ tours, setTours, packerNames, setPackerNames, onSave }) => {
            const handleOrderClick = (lat, lng, name) => {
                if (lat && lng && window.mapInstance) {
                    window.mapInstance.flyTo({ center: [lng, lat], zoom: 14, speed: 1.5 });
                    // Optional: Trigger popup if we had reference to markers, but flyTo is good enough for now
                }
            };
            const draggedItem = useRef(null);
            const draggedOverItem = useRef(null);

            const handleDragStart = (e, tourIdx, orderIdx) => {
                draggedItem.current = { tourIdx, orderIdx };
                e.dataTransfer.effectAllowed = 'move';
            };

            const handleDragEnter = (e, tourIdx, orderIdx) => {
                draggedOverItem.current = { tourIdx, orderIdx };
            };

            const handleDrop = (e) => {
                const source = draggedItem.current;
                const dest = draggedOverItem.current;
                if (!source || !dest) return;

                const newTours = [...tours];
                const sourceTour = newTours[source.tourIdx];
                const destTour = newTours[dest.tourIdx];

                const [movedOrder] = sourceTour.orders.splice(source.orderIdx, 1);

                if (dest.orderIdx >= destTour.orders.length) {
                    destTour.orders.push(movedOrder);
                } else {
                    destTour.orders.splice(dest.orderIdx, 0, movedOrder);
                }

                setTours(newTours);
                draggedItem.current = null;
                draggedOverItem.current = null;
            };

            return (
                <div className="flex bg-slate-900 border border-slate-700 h-full overflow-x-auto rounded-lg">
                    {tours.map((tour, tIdx) => {
                        const driver = DRIVERS.find(d => d.id === tour.driverId);
                        return (
                            <div key={tour.driverId}
                                className="grid-col-driver flex-1 min-w-[160px] flex flex-col border-r border-slate-700 last:border-r-0"
                                onDragEnter={(e) => handleDragEnter(e, tIdx, tour.orders.length)}
                                onDragOver={(e) => e.preventDefault()}
                                onDrop={handleDrop}
                            >
                                <div className="p-2 border-b border-slate-700 text-center font-bold text-sm" style={{ backgroundColor: driver?.color, color: '#000' }}>
                                    {driver?.name}
                                </div>
                                <div className="flex-1 overflow-y-auto p-1 space-y-1">
                                    {tour.orders.map((order, oIdx) => {
                                        const isLate = order.estimatedArrival && order.deadlineMinutes && order.estimatedArrival > order.deadlineMinutes;
                                        const arrivalTime = order.estimatedArrival
                                            ? `${Math.floor(order.estimatedArrival / 60)}:${String(Math.floor(order.estimatedArrival % 60)).padStart(2, '0')}`
                                            : null;

                                        return (
                                            <div key={order.id}
                                                draggable
                                                onDragStart={(e) => handleDragStart(e, tIdx, oIdx)}
                                                onDragEnter={(e) => { e.stopPropagation(); handleDragEnter(e, tIdx, oIdx); }}
                                                onDragOver={(e) => e.preventDefault()}
                                                onClick={() => handleOrderClick(order.lat, order.lng, order.name)}
                                                className="bg-slate-800 p-2 rounded text-xs border border-slate-600 cursor-pointer hover:bg-slate-700 draggable-item relative group hover:border-indigo-500 transition-all shadow-sm"
                                            >
                                                <div className="font-bold truncate flex items-center gap-1" title={order.name}>
                                                    <span className="text-slate-500 text-[10px] w-4">{oIdx + 1}.</span>
                                                    {order.name}
                                                </div>
                                                <div className="text-[10px] text-slate-400 truncate">{order.address?.split(',')[0]}</div>
                                                <div className="flex gap-2 mt-1 items-center justify-between">
                                                    <div className="flex gap-1">
                                                        <span className="bg-slate-700 px-1 rounded text-[9px] text-slate-300">üì¶ {order.boxes}</span>
                                                        <span className="bg-indigo-900 px-1 rounded text-[9px] text-indigo-300">üçΩÔ∏è {order.dishes || '?'}</span>
                                                    </div>
                                                    <div className="text-right flex flex-col items-end">
                                                        {order.eatingTimeMinutes && (
                                                            <span className="text-[9px] text-orange-400 font-mono mb-0.5" title="Eating Time (Deadline + 30m)">
                                                                üçΩÔ∏è {Math.floor(order.eatingTimeMinutes / 60)}:{String(order.eatingTimeMinutes % 60).padStart(2, '0')}
                                                            </span>
                                                        )}
                                                        {arrivalTime && (
                                                            <span className={`px-1 rounded text-[9px] font-bold ${isLate ? 'bg-red-900 text-red-300' : 'bg-emerald-900 text-emerald-300'}`}>
                                                                {isLate ? '‚ö†Ô∏è' : '‚úì'} {arrivalTime}
                                                            </span>
                                                        )}
                                                    </div>
                                                </div>
                                            </div>
                                        )
                                    })}
                                    {tour.orders.length === 0 && (
                                        <div className="text-center text-slate-600 text-xs italic mt-4">Empty</div>
                                    )}
                                </div>
                                <div className="p-2 border-t border-slate-700 text-[10px] text-center text-slate-400">
                                    {tour.orders.length} stops
                                </div>
                                <div className="p-2 border-t border-slate-700">
                                    <label className="text-[9px] text-slate-500 block mb-1">Packer:</label>
                                    <input
                                        type="text"
                                        placeholder="Who packs this?"
                                        value={packerNames[tour.driverId] || ''}
                                        onChange={(e) => {
                                            const newPackerNames = { ...packerNames, [tour.driverId]: e.target.value };
                                            setPackerNames(newPackerNames);
                                        }}
                                        onBlur={() => onSave(tours)}
                                        className="w-full bg-slate-800 text-slate-300 text-xs px-2 py-1 rounded border border-slate-600 focus:outline-none focus:border-indigo-500"
                                    />
                                </div>
                            </div>
                        );
                    })}
                </div>
            );
        };

        const RegistryView = () => {
            const [registry, setRegistry] = useState({});
            const processingRef = useRef(false);

            const DEFAULT_REGISTRY = {
                "Adyen N.V. Berlin": "Br√ºckenstra√üe 5, 10179 Berlin",
                "Aignostics GmbH": "Invalidenstra√üe 112, 10115 Berlin",
                "Almeida GmbH": "Oranienburger Str. 86, 10178 Berlin",
                "Alteos GmbH": "Rotherstra√üe 19, 10245 Berlin",
                "Bahnhofstr - degewo": "Bahnhofstra√üe 23, 12555 Berlin",
                "Berlin Heart": "Wiesenweg 10, 12247 Berlin",
                "Beyvers GmbH Produktion": "Sperenberger Str. 5, 12277 Berlin",
                "Beyvers GmbH Verwaltung": "Sperenberger Str. 5, 12277 Berlin",
                "Bitpanda - German Branch": "Oberwallstra√üe 6, 10117 Berlin",
                "Bonial International - bonial.com": "Hussitenstra√üe 32-33, 13355 Berlin",
                "Brunnenstr - degewo": "Brunnenstra√üe 128, 13355 Berlin",
                "Cognita Deutschland GmbH": "Friedrichstra√üe 140, 10117 Berlin",
                "Getr√§nke Hoffmann GmbH": "Am Weidendamm 1, 15831 Blankenfelde-Mahlow",
                "Halle 2 K√ºche - iSi Automotive Berlin": "Nonnendammallee 104, 13629 Berlin",
                "Halle 3 K√ºche - iSi Automotive Berlin": "Nonnendammallee 104, 13629 Berlin",
                "Ingenieurb√ºro R√ºdiger Jockwer GmbH": "B√ºlowstra√üe 66, 10783 Berlin",
                "KWS Berlin GmbH": "Potsdamer Platz 10, 10785 Berlin",
                "Kayak Germany GmbH": "Strausberger Pl. 1, 10243 Berlin",
                "Koppla GmbH": "Charlottenstra√üe 2, 10969 Berlin",
                "Kurf√ºrstenstr - degewo": "Kurf√ºrstenstra√üe 58, 10785 Berlin",
                "Lautsprecher Teufel": "Budapester Str. 44, 10787 Berlin",
                "Leapsome GmbH": "Brunnenstra√üe 153, 10115 Berlin",
                "Lovehoney Group": "Warschauer Pl. 11, 10245 Berlin",
                "Mehrower Allee - degewo": "Mehrower Allee 52, 12687 Berlin",
                "Mektec Manufacturing": "Nonnendammallee 104, 13629 Berlin",
                "Momox SE": "Schreiberhauer Str. 30, 10317 Berlin",
                "Nike (powered by CBRE) - nike.com": "M√ºhlenstra√üe 25, 10243 Berlin",
                "Omicron Energy Solutions": "Qualit√§tsweg 10, 12277 Berlin",
                "Omio": "Warschauer Pl. 12, 10245 Berlin",
                "On Cloud Service GmbH": "Skalitzer Str. 104, 10997 Berlin",
                "Parloa - Berlin": "Oberwallstra√üe 6, 10117 Berlin",
                "PenCef Pharma GmbH": "Robert-R√∂ssle-Stra√üe 10, 13125 Berlin",
                "Personio Berlin": "Sch√∂nhauser Allee 188, 10119 Berlin",
                "Pluxee - King - Midasplayer Vertriebs GmbH": "Karl-Liebknecht-Str. 32, 10178 Berlin",
                "ProBioGen AG": "Goethestra√üe 54, 13086 Berlin",
                "Safe Labs (ex Core Contributors)": "Fullerstra√üe 6, 12051 Berlin",
                "Semrush - Berlin": "Bernburger Str. 27, 10963 Berlin",
                "Shiftmove": "Oranienstra√üe 6, 10997 Berlin",
                "TAM": "Ritterstra√üe 12, 10969 Berlin",
                "TIB Molbiol Syntheselabor": "Eresburgstra√üe 22, 12103 Berlin",
                "TUI Deutschland - tui.com": "Karl-Liebknecht-Str. 19, 10178 Berlin",
                "Taxfix.de": "K√∂penicker Str. 122, 10179 Berlin",
                "Team Liquid - Liquid Enterprises GmbH": "Warschauer Str. 58, 10243 Berlin",
                "TeamViewer Germany": "Pappelallee 78, 10437 Berlin",
                "Verve Group Europe GmbH": "Karl-Liebknecht-Str. 32, 10178 Berlin",
                "Viessmann Climate Solutions": "Euref-Campus 1, 10829 Berlin",
                "byrd technologies": "Ritterstra√üe 12, 10969 Berlin",
                "charles GmbH": "Gartenstra√üe 6, 10115 Berlin",
                "gentlemates": "Gartenstra√üe 1, 10115 Berlin",
                "nexnet GmbH": "Markgrafenstra√üe 62, 10969 Berlin"
            };

            useEffect(() => {
                // Load from Firestore
                const unsubscribe = onSnapshot(collection(db, "registry"), async (snapshot) => {
                    const data = {};
                    snapshot.forEach(doc => {
                        data[doc.id] = doc.data();
                    });

                    if (Object.keys(data).length === 0 && !processingRef.current) {
                        processingRef.current = true;
                        console.log("Seeding Registry with Defaults...");
                        setRegistry(Object.fromEntries(Object.entries(DEFAULT_REGISTRY).map(([k, v]) => [k, { address: v }])));

                        const batch = writeBatch(db);
                        Object.entries(DEFAULT_REGISTRY).forEach(([name, addr]) => {
                            const docRef = doc(db, "registry", name);
                            batch.set(docRef, { address: addr });
                        });
                        try { await batch.commit(); } catch (e) { console.error("Seed failed", e); }
                    } else {
                        setRegistry(data);
                    }
                });
                return () => unsubscribe();
            }, []);

            const save = async (name, newAddress) => {
                try {
                    await setDoc(doc(db, "registry", name), { address: newAddress });
                } catch (e) {
                    console.error("Error saving to registry", e);
                    alert("Failed to save to cloud");
                }
            };

            return (
                <div className="p-8 text-white">
                    <h2 className="text-2xl font-bold mb-4">Cloud Company Registry</h2>
                    <p className="mb-4 text-slate-400">Manage customer addresses here. Data is synced to the cloud.</p>

                    <div className="grid grid-cols-2 gap-4">
                        {Object.entries(registry)
                            .sort(([a], [b]) => a.localeCompare(b)) // Alphabetical sort
                            .map(([name, data]) => (
                                <div key={name} className="bg-slate-800 p-4 rounded border border-slate-600">
                                    <input className="bg-transparent font-bold w-full mb-2 border-b border-slate-600 focus:outline-none" defaultValue={name} readOnly />
                                    <input
                                        className="bg-slate-900 w-full p-2 rounded text-sm text-slate-300"
                                        defaultValue={data.address}
                                        onBlur={(e) => save(name, e.target.value)}
                                    />
                                </div>
                            ))}
                    </div>
                    <button className="mt-4 bg-indigo-600 px-4 py-2 rounded font-bold" onClick={() => {
                        const name = prompt("Enter Company Name");
                        if (name) save(name, "");
                    }}>+ Add New Company</button>
                </div>
            )
        }

        function App() {
            const [selectedDate, setSelectedDate] = useState(() => new Date().toISOString().split('T')[0]);
            const [tours, setTours] = useState([]);
            const [view, setView] = useState('grid');
            const [loading, setLoading] = useState(false);
            const [showCalendar, setShowCalendar] = useState(false);
            const [showDriverDropdown, setShowDriverDropdown] = useState(false);
            const [driverAvailability, setDriverAvailability] = useState({});
            const [packerNames, setPackerNames] = useState({});
            const [gridHeight, setGridHeight] = useState(50); // Percentage of screen
            const [uploadProgress, setUploadProgress] = useState(0); // Progress percentage

            // Load driver availability for selected date
            useEffect(() => {
                const loadAvailability = async () => {
                    try {
                        const docRef = doc(db, "driver_availability", selectedDate);
                        const docSnap = await getDoc(docRef);

                        if (docSnap.exists()) {
                            setDriverAvailability(docSnap.data().drivers || {});
                        } else {
                            // Default: all drivers ON
                            const defaultAvail = {};
                            DRIVERS.forEach(d => { defaultAvail[d.id] = true; });
                            setDriverAvailability(defaultAvail);
                        }
                    } catch (e) {
                        console.error("Error loading availability:", e);
                    }
                };
                loadAvailability();
            }, [selectedDate]);

            useEffect(() => {
                const loadPlan = async () => {
                    setLoading(true);
                    try {
                        const docRef = doc(db, "daily_plans", selectedDate);
                        const docSnap = await getDoc(docRef);

                        if (docSnap.exists()) {
                            const data = docSnap.data();
                            if (data.tours) {
                                setTours(data.tours);
                                setPackerNames(data.packerNames || {});
                                console.log("Loaded plan for", selectedDate);
                            }
                        } else {
                            setTours([]);
                            setPackerNames({});
                        }
                    } catch (e) {
                        console.error("Error loading plan:", e);
                    } finally {
                        setLoading(false);
                    }
                };
                loadPlan();
            }, [selectedDate]);

            const toggleDriverAvailability = async (driverId) => {
                const newAvail = { ...driverAvailability, [driverId]: !driverAvailability[driverId] };
                setDriverAvailability(newAvail);

                // Save to Firebase
                try {
                    await setDoc(doc(db, "driver_availability", selectedDate), {
                        date: selectedDate,
                        drivers: newAvail,
                        lastUpdated: new Date().toISOString()
                    });
                } catch (e) {
                    console.error("Error saving availability:", e);
                }
            };

            const handleOrderMove = (orderId, targetDriverId) => {
                const newTours = [...tours];
                let movedOrder = null;

                // Find and remove order
                newTours.forEach(tour => {
                    const idx = tour.orders.findIndex(o => o.id === orderId);
                    if (idx !== -1) {
                        movedOrder = tour.orders.splice(idx, 1)[0];
                    }
                });

                // Add to target driver
                if (movedOrder && targetDriverId) {
                    const targetTour = newTours.find(t => t.driverId === targetDriverId);
                    if (targetTour) {
                        targetTour.orders.push(movedOrder);
                    }
                }

                setTours(newTours);
                // Auto-save on move? Maybe better to have explicit save or debounce.
                // For now, let's just update local state. User can re-upload to reset or we should add a "Save" button. 
                // Actually, let's auto-save to cloud on move for seamless experience.
                saveDailyPlan(newTours);
            };

            const [showUpload, setShowUpload] = useState(false);

            const saveDailyPlan = async (currentTours) => {
                // Use the currently selected date
                try {
                    await setDoc(doc(db, "daily_plans", selectedDate), {
                        date: selectedDate,
                        tours: currentTours,
                        drivers: DRIVERS,
                        packerNames: packerNames,
                        lastUpdated: new Date().toISOString()
                    });
                    console.log("Daily plan saved for " + selectedDate);
                } catch (e) {
                    console.error("Error saving daily plan", e);
                }
            };

            const processJsonData = async (jsonContent) => {
                setUploadProgress(1);
                try {
                    const json = JSON.parse(jsonContent);
                    let orders = Array.isArray(json) ? json : (json.orders || []);

                    // FILTER OUT INTERNAL ORDERS
                    orders = orders.filter(o => {
                        const name = (o.name || "").toLowerCase();
                        if (name.includes("bella") && name.includes("bona") && (name.includes("kitchen") || name.includes("potsdam"))) {
                            console.log("üö´ Filtered internal order:", o.name);
                            return false;
                        }
                        return true;
                    });

                    orders = orders.map(o => {
                        const boxCount = Array.isArray(o.boxes) ? o.boxes.length : (Number(o.boxes) || 1);

                        let dishCount = 0;
                        if (typeof o.dishes === 'number') {
                            dishCount = o.dishes;
                        } else if (Array.isArray(o.boxes)) {
                            // Try to extract dish count from nested structure similar to python logic
                            // Structure: box -> dishes -> users -> orderedQuantity
                            dishCount = o.boxes.reduce((acc, box) => {
                                const boxDishes = Array.isArray(box.dishes) ? box.dishes : [];
                                return acc + boxDishes.reduce((dAcc, dish) => {
                                    const users = Array.isArray(dish.users) ? dish.users : [];
                                    return dAcc + users.reduce((uAcc, user) => uAcc + (user.orderedQuantity || 0), 0);
                                }, 0);
                            }, 0);
                            // If deep extraction yielded 0 but we have boxes, maybe dishes are just counted differently or missing.
                            if (dishCount === 0 && o.dishes) dishCount = Number(o.dishes) || 0;
                        } else {
                            dishCount = Number(o.dishes) || 0;
                        }

                        return {
                            id: o.id || Math.random().toString(36),
                            name: o.name || "Unknown",
                            address: o.address || "",
                            postCode: o.postCode || "",
                            boxes: boxCount,
                            dishes: dishCount,
                            deliverySlotStart: o.deliverySlotStart || "09:00",
                            deliverySlotEnd: o.deliverySlotEnd || "12:00"
                        };
                    });

                    const newTours = await calculateInitialTours(orders);
                    setUploadProgress(90); // Optimization phase
                    setTours(newTours); // Update UI immediately
                    await saveDailyPlan(newTours);
                    setUploadProgress(100);
                    setTimeout(() => {
                        setShowUpload(false);
                        setUploadProgress(0);
                    }, 500);
                } catch (err) {
                    alert("Invalid JSON format");
                    setUploadProgress(0);
                }
            };


            // Geocoding cache - stores coordinates for addresses to avoid repeated API calls
            const geocodeCache = useRef({});
            const registryRef = useRef({});

            // Load geocoding cache from Firebase
            useEffect(() => {
                const unsubscribe = onSnapshot(collection(db, "geocode_cache"), (snapshot) => {
                    const cache = {};
                    snapshot.forEach(doc => {
                        cache[doc.id] = doc.data();
                    });
                    geocodeCache.current = cache;
                    console.log("Geocode cache loaded:", Object.keys(cache).length, "addresses");
                });
                return () => unsubscribe();
            }, []);

            // Load registry for address lookup
            useEffect(() => {
                const unsubscribe = onSnapshot(collection(db, "registry"), (snapshot) => {
                    const reg = {};
                    snapshot.forEach(doc => {
                        reg[doc.id] = doc.data();
                    });
                    registryRef.current = reg;
                    console.log("Registry loaded:", Object.keys(reg).length, "companies");
                });
                return () => unsubscribe();
            }, []);

            // Geocode an address and cache the result
            const geocodeAddress = async (address, companyName) => {
                // Check cache first
                const cacheKey = companyName || address;
                if (geocodeCache.current[cacheKey]) {
                    const cached = geocodeCache.current[cacheKey];
                    if (cached.lat && cached.lng) {
                        console.log("‚úÖ Cache hit for:", cacheKey);
                        return { lat: cached.lat, lng: cached.lng };
                    }
                }

                // Geocode using Nominatim
                try {
                    const query = address ? `${address}, Berlin, Germany` : `${companyName}, Berlin, Germany`;
                    const res = await fetch(`https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(query)}&format=json&limit=1`, {
                        headers: { 'User-Agent': 'BellaBona-IntelliRoute/2.0' }
                    });
                    const data = await res.json();

                    if (data && data.length > 0) {
                        const coords = { lat: parseFloat(data[0].lat), lng: parseFloat(data[0].lon) };

                        // Cache the result in Firebase
                        try {
                            await setDoc(doc(db, "geocode_cache", cacheKey), {
                                ...coords,
                                address: address,
                                companyName: companyName,
                                lastUpdated: new Date().toISOString()
                            });
                            console.log("‚úÖ Geocoded and cached:", cacheKey, coords);
                        } catch (e) {
                            console.warn("Cache save failed:", e);
                        }

                        return coords;
                    }
                } catch (e) {
                    console.error("Geocoding failed for:", cacheKey, e);
                }

                return null;
            };

            const haversine = (lat1, lon1, lat2, lon2) => {
                const R = 6371; // km
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLon = (lon2 - lon1) * Math.PI / 180;
                const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLon / 2) * Math.sin(dLon / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                return R * c;
            };

            const calculateInitialTours = async (orders) => {
                setLoading(true);
                const newTours = DRIVERS.map(d => ({ driverId: d.id, driverName: d.name, orders: [] }));

                const unassigned = [];
                const assignedIds = new Set();

                // Geocode orders using Registry as source of truth
                let processedCount = 0;
                const totalOrders = orders.length;

                for (const order of orders) {
                    processedCount++;
                    // Update progress every 5 orders or so to avoid too many re-renders
                    if (processedCount % 5 === 0 || processedCount === totalOrders) {
                        setUploadProgress(Math.floor((processedCount / totalOrders) * 80)); // Geocoding is 80% of the work
                    }

                    if (!order.lat || !order.lng) {
                        // Smart branch matching: "Nike - Mitte" should match "Nike (powered by CBRE)" in Registry
                        let registryEntry = registryRef.current[order.name];

                        // If exact match not found, try fuzzy matching for branches
                        if (!registryEntry) {
                            const baseName = order.name.split('-')[0].trim();
                            const matchingKey = Object.keys(registryRef.current).find(key =>
                                key.toLowerCase().includes(baseName.toLowerCase()) ||
                                baseName.toLowerCase().includes(key.split(/[-()]/)[0].trim().toLowerCase())
                            );
                            if (matchingKey) {
                                registryEntry = registryRef.current[matchingKey];
                                console.log(`üîó Branch matched: "${order.name}" ‚Üí "${matchingKey}"`);
                            }
                        }

                        if (registryEntry && registryEntry.address) {
                            // Use Registry address
                            const coords = await geocodeAddress(registryEntry.address, order.name);
                            if (coords) {
                                order.lat = coords.lat;
                                order.lng = coords.lng;
                                order.address = registryEntry.address;
                            }
                        } else if (order.address) {
                            // Fall back to JSON address if not in Registry
                            console.warn("‚ö†Ô∏è Company not in Registry:", order.name, "- using JSON address");
                            const coords = await geocodeAddress(order.address, order.name);
                            if (coords) {
                                order.lat = coords.lat;
                                order.lng = coords.lng;
                            }
                        } else {
                            // Last resort: geocode company name
                            console.warn("‚ö†Ô∏è No address found for:", order.name, "- geocoding company name");
                            const coords = await geocodeAddress("", order.name);
                            if (coords) {
                                order.lat = coords.lat;
                                order.lng = coords.lng;
                            }
                        }
                    }

                    let assigned = false;
                    for (const [driverId, keywords] of Object.entries(GOLDEN_PLAN)) {
                        // Only assign to drivers who are ON for this date
                        if (!driverAvailability[driverId]) continue;

                        const match = keywords.some(k => order.name.toLowerCase().includes(k.toLowerCase()));
                        if (match) {
                            const tour = newTours.find(t => t.driverId === driverId);
                            if (tour) {
                                tour.orders.push(order);
                                assignedIds.add(order.id);
                                assigned = true;
                                break;
                            }
                        }
                    }
                    if (!assigned) unassigned.push(order);
                }

                // Sort unassigned by Postal Code for rough clustering before distribution
                unassigned.sort((a, b) => {
                    const zipA = a.postCode || a.address?.match(/\d{5}/)?.[0] || "00000";
                    const zipB = b.postCode || b.address?.match(/\d{5}/)?.[0] || "00000";
                    return zipA.localeCompare(zipB);
                });

                // DISTRIBUTE UNASSIGNED ORDERS: "Crystal Growth" Clustering
                // Instead of Round Robin, assign each order to the driver who is CLOSEST to it
                // This builds natural geographic zones preventing "messy" crossing routes

                // Only distribute to active drivers
                const activeTours = newTours.filter(t => driverAvailability[t.driverId] !== false);
                const MAX_STOPS = 25; // Soft limit per driver

                // PRIORITIZE ASSIGNMENT:
                // 1. Sort by Deadline (Urgent first) -> Ensures drivers serve urgent/eating time needs
                // 2. Then by Postal Code -> Groups remaining geographically
                unassigned.sort((a, b) => {
                    // Parse deadlines (e.g. "12:00")
                    const getMinutes = (timeStr) => {
                        if (!timeStr) return 9999;
                        const [h, m] = timeStr.split(':').map(Number);
                        return h * 60 + m;
                    };
                    const timeA = getMinutes(a.deliverySlotEnd);
                    const timeB = getMinutes(b.deliverySlotEnd);

                    if (timeA !== timeB) return timeA - timeB; // Earlier deadline first
                    return (a.postCode || "").localeCompare(b.postCode || ""); // Then postal code
                });

                unassigned.forEach(order => {
                    let bestTour = null;
                    let minAddedDist = Infinity;

                    // Find the best driver for this order
                    activeTours.forEach(tour => {
                        if (tour.orders.length >= MAX_STOPS) return; // Skip full drivers

                        let distToTour = Infinity;

                        if (tour.orders.length === 0) {
                            // If tour is empty, measure from Kitchen (Potsdam)
                            // This effectively assigns closest-to-kitchen orders to fresh drivers first
                            if (order.lat && order.lng) {
                                distToTour = haversine(POTSDAM_KITCHEN.lat, POTSDAM_KITCHEN.lng, order.lat, order.lng);
                            } else {
                                distToTour = 9999; // Penalty for no coords
                            }
                        } else {
                            // Find distance to the NEAREST stop in this driver's current route
                            // This ensures we group nearby orders together
                            tour.orders.forEach(stop => {
                                if (stop.lat && stop.lng && order.lat && order.lng) {
                                    const d = haversine(stop.lat, stop.lng, order.lat, order.lng);
                                    if (d < distToTour) distToTour = d;
                                }
                            });
                            // If order has no coords, skip geometric matching (or assign randomly later)
                            if (!order.lat || !order.lng) distToTour = 9999;
                        }

                        // We want the driver who is ALREADY closest to this order
                        if (distToTour < minAddedDist) {
                            minAddedDist = distToTour;
                            bestTour = tour;
                        }
                    });

                    // If we found a suitable driver, assign it
                    if (bestTour) {
                        bestTour.orders.push(order);
                    } else {
                        // If all drivers full (or none active), fallback to first active or random
                        if (activeTours.length > 0) {
                            activeTours[0].orders.push(order); // Overfill if necessary
                        } else {
                            console.error("No active drivers to assign order:", order.name);
                        }
                    }
                });

                // OPTIMIZE ROUTES: Time-Based Nearest Neighbor with Delivery Windows
                const DEPARTURE_TIME = 10 * 60; // 10:00 AM in minutes
                const AVG_SPEED_KM_PER_MIN = 1 / 3; // 20 km/h average in Berlin traffic
                const STOP_TIME_MINUTES = 5; // Time to park, deliver, leave

                newTours.forEach(tour => {
                    if (tour.orders.length === 0) return;

                    // Parse delivery times and add urgency score
                    tour.orders.forEach(order => {
                        // Parse delivery slot end time (e.g., "12:00")
                        const [hours, mins] = (order.deliverySlotEnd || "12:00").split(':').map(Number);
                        order.deadlineMinutes = hours * 60 + mins;

                        // Eating time is typically 30 min after delivery slot end
                        order.eatingTimeMinutes = order.deadlineMinutes + 30;
                    });

                    const optimized = [];
                    let currentPos = POTSDAM_KITCHEN;
                    let currentTime = DEPARTURE_TIME;
                    const pool = [...tour.orders];

                    while (pool.length > 0) {
                        let bestIdx = -1;
                        let bestScore = -Infinity;

                        pool.forEach((o, idx) => {
                            if (!o.lat || !o.lng) {
                                // Orders without coords go last
                                if (bestIdx === -1) bestIdx = idx;
                                return;
                            }

                            const distance = haversine(currentPos.lat, currentPos.lng, o.lat, o.lng);
                            const driveTime = distance / AVG_SPEED_KM_PER_MIN;
                            const arrivalTime = currentTime + driveTime + STOP_TIME_MINUTES;

                            // Calculate urgency: how much time buffer before deadline
                            const timeUntilDeadline = o.deadlineMinutes - arrivalTime;

                            // SCORING ALGORITHM - STRICT TIME ADHERENCE
                            // Priority 1: Meet the Deadline (Urgency)
                            // Priority 2: Minimize Travel Distance

                            let score = 0;

                            if (timeUntilDeadline < 0) {
                                // LATE: Penalty increases with lateness to minimize it
                                score = -100000 + timeUntilDeadline;
                            } else {
                                // ON TIME:
                                // To ensure strict sequential time delivery (10:30 before 11:00),
                                // we heavily weight the deadline time itself.
                                // We invert the deadline minutes (1440 - deadline) so earlier = higher score.
                                // Weight: 1 minute of earlier deadline = 100 points
                                // Distance Weight: 1km = 50 points

                                const deadlineScore = (1440 - o.deadlineMinutes) * 100;
                                const distancePenalty = distance * 50;

                                // Result: 11:00 deadline (660m) vs 10:30 (630m)
                                // 10:30 gets +3000 points.
                                // To override this, the 11:00 stop would need to be 60km closer!
                                // This enforces strict time sequencing unless it's insanely inefficient.
                                score = deadlineScore - distancePenalty;
                            }

                            if (score > bestScore) {
                                bestScore = score;
                                bestIdx = idx;
                            }
                        });

                        if (bestIdx === -1) bestIdx = 0;

                        const nextStop = pool.splice(bestIdx, 1)[0];

                        // Update current time and position
                        if (nextStop.lat && nextStop.lng) {
                            const distance = haversine(currentPos.lat, currentPos.lng, nextStop.lat, nextStop.lng);
                            const driveTime = distance / AVG_SPEED_KM_PER_MIN;
                            currentTime += driveTime + STOP_TIME_MINUTES;
                            currentPos = nextStop;

                            // Store estimated arrival for display
                            nextStop.estimatedArrival = Math.floor(currentTime);

                            // Check if we'll be late
                            if (currentTime > nextStop.deadlineMinutes) {
                                console.warn(`‚ö†Ô∏è Late delivery: ${nextStop.name} - Arrival: ${Math.floor(currentTime / 60)}:${String(Math.floor(currentTime % 60)).padStart(2, '0')}, Deadline: ${nextStop.deliverySlotEnd}`);
                            }
                        }

                        optimized.push(nextStop);
                    }
                    tour.orders = optimized;
                });

                setTours(newTours);
                setLoading(false);
                return newTours;
            };

            // Modal Component
            // Modal Component
            const UploadModal = () => {
                const [text, setText] = useState("");
                return (
                    <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4">
                        <div className="bg-slate-900 border border-slate-700 p-6 rounded-xl w-full max-w-2xl shadow-2xl">
                            <h2 className="text-xl font-bold text-white mb-2">Upload Daily Plan</h2>
                            <p className="text-slate-400 text-sm mb-2">Paste your daily orders JSON here. This will generate routes and save the plan to the cloud.</p>
                            <div className="bg-indigo-900/30 border border-indigo-700 rounded-lg px-4 py-2 mb-4">
                                <span className="text-xs text-indigo-300 font-bold">üìÖ Saving to: {selectedDate}</span>
                            </div>

                            {uploadProgress > 0 && uploadProgress < 100 ? (
                                <div className="mb-4">
                                    <div className="flex justify-between text-xs text-slate-300 mb-1">
                                        <span>Processing geography & routes...</span>
                                        <span>{uploadProgress}%</span>
                                    </div>
                                    <div className="w-full bg-slate-800 rounded-full h-2.5">
                                        <div className="bg-indigo-600 h-2.5 rounded-full transition-all duration-300" style={{ width: `${uploadProgress}%` }}></div>
                                    </div>
                                </div>
                            ) : (
                                <textarea
                                    className="w-full h-64 bg-slate-950 border border-slate-800 rounded p-4 text-xs font-mono text-slate-300 focus:outline-none focus:border-indigo-500"
                                    placeholder='[ { "name": "Company A", ... }, ... ]'
                                    value={text}
                                    onChange={(e) => setText(e.target.value)}
                                />
                            )}

                            <div className="flex justify-end gap-3 mt-4">
                                <button onClick={() => setShowUpload(false)} className="px-4 py-2 rounded text-slate-400 font-bold hover:text-white transition-colors">Cancel</button>
                                <button
                                    onClick={() => processJsonData(text)}
                                    disabled={uploadProgress > 0 && uploadProgress < 100}
                                    className={`px-6 py-2 rounded font-bold transition-colors ${uploadProgress > 0 ? 'bg-slate-700 text-slate-400 cursor-not-allowed' : 'bg-indigo-600 hover:bg-indigo-500 text-white'}`}
                                >
                                    {uploadProgress > 0 && uploadProgress < 100 ? 'Processing...' : 'Process & Save Plan'}
                                </button>
                            </div>
                        </div>
                    </div>
                );
            };

            // Calendar Modal Component
            const CalendarModal = () => {
                const [month, setMonth] = useState(new Date(selectedDate));
                const daysInMonth = new Date(month.getFullYear(), month.getMonth() + 1, 0).getDate();
                const firstDay = new Date(month.getFullYear(), month.getMonth(), 1).getDay();
                const days = Array.from({ length: daysInMonth }, (_, i) => i + 1);
                const blanks = Array.from({ length: firstDay === 0 ? 6 : firstDay - 1 });

                const selectDate = (day) => {
                    const yyyy = month.getFullYear();
                    const mm = String(month.getMonth() + 1).padStart(2, '0');
                    const dd = String(day).padStart(2, '0');
                    setSelectedDate(`${yyyy}-${mm}-${dd}`);
                    setShowCalendar(false);
                };

                return (
                    <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4" onClick={() => setShowCalendar(false)}>
                        <div className="bg-slate-900 border border-slate-700 p-6 rounded-xl shadow-2xl" onClick={(e) => e.stopPropagation()}>
                            <div className="flex items-center justify-between mb-4">
                                <button onClick={() => setMonth(new Date(month.setMonth(month.getMonth() - 1)))} className="text-white hover:text-indigo-400">‚óÄ</button>
                                <h3 className="text-white font-bold">{month.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}</h3>
                                <button onClick={() => setMonth(new Date(month.setMonth(month.getMonth() + 1)))} className="text-white hover:text-indigo-400">‚ñ∂</button>
                            </div>
                            <div className="grid grid-cols-7 gap-2">
                                {['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'].map(d => (
                                    <div key={d} className="text-center text-xs text-slate-400 font-bold p-2">{d}</div>
                                ))}
                                {blanks.map((_, i) => <div key={`blank-${i}`} />)}
                                {days.map(day => {
                                    const isSelected = selectedDate === `${month.getFullYear()}-${String(month.getMonth() + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                                    return (
                                        <button
                                            key={day}
                                            onClick={() => selectDate(day)}
                                            className={`p-2 rounded text-sm font-bold transition-all ${isSelected ? 'bg-indigo-600 text-white' : 'bg-slate-800 text-slate-300 hover:bg-slate-700'
                                                }`}
                                        >
                                            {day}
                                        </button>
                                    );
                                })}
                            </div>
                        </div>
                    </div>
                );
            };

            // Driver Availability Dropdown Modal
            const DriverAvailabilityModal = () => {
                return (
                    <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4" onClick={() => setShowDriverDropdown(false)}>
                        <div className="bg-slate-900 border border-slate-700 p-6 rounded-xl shadow-2xl max-w-md" onClick={(e) => e.stopPropagation()}>
                            <h3 className="text-white font-bold mb-4 text-lg">Driver Availability - {selectedDate}</h3>
                            <div className="space-y-2 max-h-96 overflow-y-auto">
                                {DRIVERS.map(driver => {
                                    const isOn = driverAvailability[driver.id] !== false;
                                    return (
                                        <div key={driver.id} className="flex items-center justify-between bg-slate-800 p-3 rounded border border-slate-700">
                                            <div className="flex items-center gap-3">
                                                <div className="w-4 h-4 rounded-full" style={{ backgroundColor: driver.color }} />
                                                <span className="text-white font-medium">{driver.name}</span>
                                            </div>
                                            <button
                                                onClick={() => toggleDriverAvailability(driver.id)}
                                                className={`px-4 py-2 rounded font-bold text-xs transition-all ${isOn
                                                    ? 'bg-emerald-600 text-white hover:bg-emerald-500'
                                                    : 'bg-slate-700 text-slate-400 hover:bg-slate-600'
                                                    }`}
                                            >
                                                {isOn ? '‚úì ON' : '‚úó OFF'}
                                            </button>
                                        </div>
                                    );
                                })}
                            </div>
                            <button
                                onClick={() => setShowDriverDropdown(false)}
                                className="mt-4 w-full bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-4 rounded transition-colors"
                            >
                                Done
                            </button>
                        </div>
                    </div>
                );
            };

            const handleFileUpload = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => processJsonData(event.target.result);
                reader.readAsText(file);
            };

            const exportToCSV = () => {
                let csv = "Driver,Stop Number,Company,Address,Postal Code,Boxes,Dishes\n";
                tours.forEach(t => {
                    t.orders.forEach((o, i) => {
                        csv += `${t.driverName},${i + 1},"${o.name}","${o.address}",${o.postCode},${o.boxes},${o.dishes || 0}\n`;
                    });
                });
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `routing_schedule_${new Date().toISOString().split('T')[0]}.csv`;
                a.click();
            };

            return (
                <div className="h-screen flex flex-col bg-slate-950">
                    {showUpload && <UploadModal />}
                    {showCalendar && <CalendarModal />}
                    {showDriverDropdown && <DriverAvailabilityModal />}
                    <header className="bg-slate-900 border-b border-slate-700 h-16 flex items-center px-6 justify-between shrink-0 shadow-lg z-10">
                        <div className="flex items-center gap-6">
                            <h1 className="font-black text-xl tracking-tight text-white">BELLA<span className="text-indigo-500">BONA</span> ROT</h1>
                            <nav className="flex bg-slate-800 p-1 rounded-lg">
                                <button onClick={() => setView('grid')} className={`px-4 py-1.5 rounded-md text-xs font-bold transition-all ${view === 'grid' ? 'bg-indigo-600 text-white shadow' : 'text-slate-400 hover:text-white'}`}>GRID PLAN</button>
                                <button onClick={() => setView('registry')} className={`px-4 py-1.5 rounded-md text-xs font-bold transition-all ${view === 'registry' ? 'bg-indigo-600 text-white shadow' : 'text-slate-400 hover:text-white'}`}>REGISTRY</button>
                            </nav>
                        </div>
                        <div className="flex items-center gap-3">
                            <button
                                onClick={() => setShowCalendar(true)}
                                className="flex items-center gap-2 bg-slate-800 px-3 py-2 rounded border border-slate-600 hover:border-indigo-500 transition-colors cursor-pointer"
                            >
                                <span className="text-xs text-slate-400 font-bold">üìÖ</span>
                                <span className="text-slate-300 text-xs font-mono">{selectedDate}</span>
                            </button>
                            <button
                                onClick={() => setShowDriverDropdown(true)}
                                className="bg-slate-800 hover:bg-slate-700 text-slate-300 text-xs font-bold px-3 py-2 rounded border border-slate-600 transition-colors flex items-center gap-2"
                            >
                                <span>üöó DRIVERS</span>
                            </button>
                            <button onClick={() => setShowUpload(true)} className="bg-slate-800 hover:bg-slate-700 text-slate-300 text-xs font-bold px-3 py-2 rounded border border-slate-600 transition-colors flex items-center gap-2">
                                <span>üì§ UPLOAD / PASTE JSON</span>
                            </button>
                            <button onClick={exportToCSV} className="bg-emerald-600 hover:bg-emerald-500 text-white text-xs font-bold px-4 py-2 rounded shadow transition-all flex items-center gap-2">
                                <span>DOWNLOAD CSV</span>
                            </button>
                        </div>
                    </header>

                    <main className="flex-1 flex overflow-hidden relative">
                        {view === 'grid' && (
                            <div className="w-full h-full flex flex-col">
                                <div style={{ height: `${gridHeight}%` }} className="border-b border-slate-700 relative group">
                                    <RouteMap tours={tours.filter(t => driverAvailability[t.driverId] !== false)} height={600} onOrderMove={handleOrderMove} onGeocodeUpdate={(id, lat, lng) => {
                                        setTours(prev => prev.map(t => ({
                                            ...t,
                                            orders: t.orders.map(o => o.id === id ? { ...o, lat, lng } : o)
                                        })));
                                    }} />
                                    <div className="absolute top-4 left-4 bg-slate-900/90 text-white p-3 rounded border border-white/10 backdrop-blur text-xs z-50 pointer-events-none">
                                        <div className="font-bold text-slate-400 mb-1">TOTAL ORDERS</div>
                                        <div className="text-2xl font-black">{tours.filter(t => driverAvailability[t.driverId] !== false).reduce((acc, t) => acc + t.orders.length, 0)}</div>
                                    </div>
                                    {/* Resize Handle */}
                                    <div
                                        className="absolute bottom-0 left-0 right-0 h-2 bg-indigo-600/20 hover:bg-indigo-600/50 cursor-ns-resize group-hover:opacity-100 opacity-0 transition-opacity"
                                        onMouseDown={(e) => {
                                            const startY = e.clientY;
                                            const startHeight = gridHeight;
                                            const onMove = (e) => {
                                                const delta = ((e.clientY - startY) / window.innerHeight) * 100;
                                                setGridHeight(Math.max(20, Math.min(80, startHeight + delta)));
                                            };
                                            const onUp = () => {
                                                document.removeEventListener('mousemove', onMove);
                                                document.removeEventListener('mouseup', onUp);
                                            };
                                            document.addEventListener('mousemove', onMove);
                                            document.addEventListener('mouseup', onUp);
                                        }}
                                    />
                                </div>
                                <div style={{ height: `${100 - gridHeight}%` }} className="bg-slate-900 p-2">
                                    <GridView
                                        tours={tours.filter(t => driverAvailability[t.driverId] !== false)}
                                        setTours={setTours}
                                        packerNames={packerNames}
                                        setPackerNames={setPackerNames}
                                        onSave={saveDailyPlan}
                                    />
                                </div>
                            </div>
                        )}

                        {view === 'registry' && <div className="w-full h-full overflow-y-auto"><RegistryView /></div>}
                    </main>
                </div>
            );
        }

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>