<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BellaBona IntelliRoute</title>

    <!-- External Utilities -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;900&display=swap"
        rel="stylesheet">
    <link href="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.css" rel="stylesheet" />

    <!-- Babel & React/Firebase from CDN -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #0f172a;
        }

        ::-webkit-scrollbar-thumb {
            background: #334155;
            border-radius: 4px;
        }

        .map-dark-mode canvas {
            filter: invert(100%) hue-rotate(180deg) brightness(95%) contrast(90%);
        }

        .scrollbar-hide::-webkit-scrollbar {
            display: none;
        }
    </style>

    <!-- Error Handler -->
    <script>
        window.onerror = function (msg, url, line, col, error) {
            document.body.innerHTML = `
                <div style="background:#0f172a;color:#ef4444;padding:40px;font-family:monospace;height:100vh;display:flex;flex-col;justify-content:center;align-items:center;">
                    <div style="max-width:800px;">
                        <h1 style="font-size:24px;margin-bottom:20px;">SYSTEM CRITICAL ERROR</h1>
                        <p style="background:#1e293b;padding:20px;border-radius:10px;border:1px solid #334155;">${msg}</p>
                        <p style="color:#64748b;margin-top:10px;">${url}:${line}:${col}</p>
                    </div>
                </div>
            `;
            console.error("Critical Error:", error);
            return false;
        };
    </script>

    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "@google/generative-ai": "https://esm.sh/@google/generative-ai@0.21.0",
        "firebase/app": "https://esm.sh/firebase@11.1.0/app",
        "firebase/firestore": "https://esm.sh/firebase@11.1.0/firestore",
        "maplibre-gl": "https://esm.sh/maplibre-gl@4.7.1"
      }
    }
    </script>
</head>

<body class="bg-slate-950 text-slate-200">
    <div id="root"></div>

    <script type="text/babel" data-presets="react,typescript" data-type="module">
        import React, { useState, useEffect, useMemo, useRef } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as firebaseApp from 'firebase/app';
        import {
            getFirestore,
            initializeFirestore,
            persistentLocalCache,
            persistentMultipleTabManager,
            collection,
            doc,
            setDoc,
            onSnapshot,
            writeBatch,
            getDocs
        } from 'firebase/firestore';
        import { GoogleGenerativeAI } from '@google/generative-ai';
        import { Map as MapLibreMap, NavigationControl, AttributionControl, Marker, Popup, LngLatBounds } from 'maplibre-gl';

        // --- ENUMS & TYPES ---
        const Area = {
            PANKOW: 'Pankow',
            PRENZLAUER_BERG: 'Prenzlauer Berg',
            WEISSENSEE: 'Weissensee',
            REINICKENDORF: 'Reinickendorf',
            KOEPENICK: 'Köpenick',
            TREPTOW: 'Treptow',
            MITTE_ZENTRUM: 'Mitte (Zentrum)',
            TIERGARTEN: 'Tiergarten',
            MOABIT: 'Moabit',
            WEDDING: 'Wedding',
            CHARLOTTENBURG: 'Charlottenburg',
            WILMERSDORF: 'Wilmersdorf',
            SPANDAU: 'Spandau',
            FRIEDRICHSHAIN: 'Friedrichshain',
            LICHTENBERG: 'Lichtenberg',
            MARZAHN: 'Marzahn',
            HELLERSDORF: 'Hellersdorf',
            KREUZBERG: 'Kreuzberg',
            NEUKOELLN: 'Neukölln',
            SCHOENEBERG: 'Schöneberg',
            TEMPELHOF: 'Tempelhof',
            STEGLITZ: 'Steglitz',
            ZEHLENDORF: 'Zehlendorf',
            OTHER: 'Other'
        };

        const BoxStatus = {
            PENDING: 'Pending',
            COLLECTED: 'Collected'
        };

        // --- CONSTANTS ---
        const DRIVERS = [
            { id: 'samir', name: 'Samir', level: 1, preferredArea: Area.KOEPENICK, capacity: 14, isActive: true },
            { id: 'ali2', name: 'Ali 2', level: 1, preferredArea: Area.PANKOW, capacity: 8, isActive: true },
            { id: 'josef', name: 'Jozef', level: 3, capacity: 8, isActive: true },
            { id: 'ali1', name: 'Ali 1', level: 3, capacity: 8, isActive: true },
            { id: 'ankush', name: 'Ankush', level: 2, capacity: 14, isActive: true },
            { id: 'harsh', name: 'Harsh', level: 4, capacity: 10, isActive: true },
            { id: 'packtor3', name: 'Packtor 3', level: 4, capacity: 7, isActive: true },
            { id: 'packator2', name: 'Packtor 2', level: 4, capacity: 7, isActive: true },
            { id: 'packator1', name: 'Packtor 1', level: 4, capacity: 7, isActive: true },
        ];

        const START_TIME_MINS = 630;
        const DEADLINE_MINS = 750;

        const SECTOR_GROUPS = {
            [Area.PANKOW]: [Area.PRENZLAUER_BERG, Area.WEISSENSEE, Area.REINICKENDORF],
            [Area.MITTE_ZENTRUM]: [Area.TIERGARTEN, Area.MOABIT, Area.WEDDING, Area.PRENZLAUER_BERG],
            [Area.KREUZBERG]: [Area.NEUKOELLN, Area.SCHOENEBERG, Area.TEMPELHOF, Area.FRIEDRICHSHAIN],
            [Area.CHARLOTTENBURG]: [Area.WILMERSDORF, Area.SPANDAU, Area.STEGLITZ, Area.ZEHLENDORF],
            [Area.KOEPENICK]: [Area.TREPTOW, Area.LICHTENBERG, Area.NEUKOELLN],
            [Area.OTHER]: [],
            [Area.PRENZLAUER_BERG]: [Area.PANKOW, Area.MITTE_ZENTRUM],
            [Area.WEISSENSEE]: [Area.PANKOW, Area.LICHTENBERG],
            [Area.REINICKENDORF]: [Area.PANKOW, Area.WEDDING],
            [Area.TREPTOW]: [Area.KOEPENICK, Area.NEUKOELLN],
            [Area.TIERGARTEN]: [Area.MITTE_ZENTRUM, Area.CHARLOTTENBURG],
            [Area.MOABIT]: [Area.MITTE_ZENTRUM, Area.WEDDING],
            [Area.WEDDING]: [Area.MITTE_ZENTRUM, Area.REINICKENDORF],
            [Area.WILMERSDORF]: [Area.CHARLOTTENBURG, Area.SCHOENEBERG],
            [Area.SPANDAU]: [Area.CHARLOTTENBURG],
            [Area.FRIEDRICHSHAIN]: [Area.LICHTENBERG, Area.KREUZBERG],
            [Area.LICHTENBERG]: [Area.FRIEDRICHSHAIN, Area.MARZAHN],
            [Area.MARZAHN]: [Area.LICHTENBERG, Area.HELLERSDORF],
            [Area.HELLERSDORF]: [Area.MARZAHN],
            [Area.NEUKOELLN]: [Area.KREUZBERG, Area.TREPTOW, Area.TEMPELHOF],
            [Area.SCHOENEBERG]: [Area.TEMPELHOF, Area.KREUZBERG, Area.WILMERSDORF],
            [Area.TEMPELHOF]: [Area.SCHOENEBERG, Area.NEUKOELLN, Area.STEGLITZ],
            [Area.STEGLITZ]: [Area.ZEHLENDORF, Area.TEMPELHOF],
            [Area.ZEHLENDORF]: [Area.STEGLITZ, Area.WILMERSDORF],
        };

        const DRIVER_SECTORS = {
            'samir': [Area.KOEPENICK, Area.TREPTOW],
            'ali2': [Area.PANKOW, Area.REINICKENDORF, Area.WEISSENSEE],
            'josef': [Area.MITTE_ZENTRUM, Area.TIERGARTEN, Area.MOABIT, Area.WEDDING],
            'ali1': [Area.FRIEDRICHSHAIN, Area.LICHTENBERG, Area.MARZAHN, Area.HELLERSDORF],
            'ankush': [Area.KREUZBERG, Area.NEUKOELLN, Area.SCHOENEBERG, Area.TEMPELHOF],
            'harsh': [Area.ZEHLENDORF, Area.STEGLITZ, Area.CHARLOTTENBURG, Area.WILMERSDORF, Area.SPANDAU],
        };

        const DRIVER_COLORS = {
            'samir': { bg: 'bg-amber-500', border: 'border-amber-500', hex: '#f59e0b' },
            'ali2': { bg: 'bg-emerald-500', border: 'border-emerald-500', hex: '#10b981' },
            'josef': { bg: 'bg-indigo-500', border: 'border-indigo-500', hex: '#6366f1' },
            'ali1': { bg: 'bg-pink-500', border: 'border-pink-500', hex: '#ec4899' },
            'ankush': { bg: 'bg-blue-500', border: 'border-blue-500', hex: '#3b82f6' },
            'harsh': { bg: 'bg-violet-500', border: 'border-violet-500', hex: '#8b5cf6' },
            'default': { bg: 'bg-slate-500', border: 'border-slate-500', hex: '#64748b' }
        };

        // --- FIREBASE INIT ---
        const firebaseConfig = {
            apiKey: "AIzaSyBCljwsTQ-PHm20VP-i8VByNrRwVFgMl5I",
            authDomain: "routing-4aab8.firebaseapp.com",
            databaseURL: "https://routing-4aab8-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "routing-4aab8",
            storageBucket: "routing-4aab8.firebasestorage.app",
            messagingSenderId: "148497920348",
            appId: "1:148497920348:web:0e14c31aa4dfde00205199"
        };
        const app = firebaseApp.initializeApp(firebaseConfig);
        const db = initializeFirestore(app, {
            ignoreUndefinedProperties: true,
            localCache: persistentLocalCache({ tabManager: persistentMultipleTabManager() })
        });

        // --- UTILS ---
        const parseAddress = (address) => {
            const match = address.match(/^([A-Za-zÄÖÜäöüß\s.-]+)\s*(\d+)/);
            if (match) return { street: match[1].trim().toLowerCase(), building: parseInt(match[2], 10) || 0 };
            return { street: address.toLowerCase(), building: 0 };
        };

        function calculateTravelTime(from, to) {
            if (!from || !to) return 5;
            if (from.street === to.street && from.building === to.building) return 1;
            if (from.street === to.street && Math.abs(from.building - to.building) <= 2) return 2;
            if (from.street === to.street) return 5;
            if (from.postCode === to.postCode) return 10;
            if (from.area === to.area) return 15;
            return 30;
        }

        function calculateEstimatedTime(orders) {
            let time = START_TIME_MINS + 45;
            for (let i = 1; i < orders.length; i++) {
                time += calculateTravelTime(orders[i - 1], orders[i]);
                time += 3;
            }
            return time;
        }

        function createGeographicClusters(orders) {
            const clusters = [];
            const processed = new Set();
            const sorted = [...orders].sort((a, b) => {
                if (a.area !== b.area) return a.area.localeCompare(b.area);
                if (a.postCode !== b.postCode) return a.postCode.localeCompare(b.postCode);
                if (a.street !== b.street) return a.street.localeCompare(b.street);
                return a.building - b.building;
            });
            for (const order of sorted) {
                if (processed.has(order.orderId)) continue;
                const cluster = [order];
                processed.add(order.orderId);
                for (const candidate of sorted) {
                    if (processed.has(candidate.orderId)) continue;
                    if (candidate.street === order.street && Math.abs(candidate.building - order.building) <= 5) {
                        cluster.push(candidate);
                        processed.add(candidate.orderId);
                    } else if (candidate.street === order.street) {
                        cluster.push(candidate);
                        processed.add(candidate.orderId);
                    } else if (candidate.postCode === order.postCode && candidate.area === order.area) {
                        cluster.push(candidate);
                        processed.add(candidate.orderId);
                    }
                }
                clusters.push(cluster);
            }
            return clusters.sort((a, b) => b.length - a.length);
        }

        function optimizeTourSequence(orders) {
            if (orders.length <= 1) return orders;
            const optimized = [];
            const remaining = [...orders];
            optimized.push(remaining.shift());
            while (remaining.length > 0) {
                const current = optimized[optimized.length - 1];
                let bestIdx = 0;
                let bestScore = Infinity;
                for (let i = 0; i < remaining.length; i++) {
                    const score = calculateTravelTime(current, remaining[i]);
                    if (score < bestScore) {
                        bestScore = score;
                        bestIdx = i;
                    }
                }
                optimized.push(remaining.splice(bestIdx, 1)[0]);
            }
            return optimized;
        }

        const calculateTours = (rawOrders, companies, availableDrivers) => {
            const companyMap = new Map(companies.map(c => [c.companyId, c]));
            let orderPool = (Array.isArray(rawOrders) ? rawOrders : [rawOrders])
                .map(o => {
                    const cid = o.companyId || o.id;
                    const detail = companyMap.get(cid) || companies.find(c => c.name.toLowerCase() === (o.name || '').toLowerCase());
                    const addr = o.deliveryAddress || detail?.address || '';
                    const { street, building } = parseAddress(addr);
                    return {
                        ...o,
                        orderId: o.orderId || o.id || Math.random().toString(36).substr(2, 9),
                        companyId: detail?.companyId || cid,
                        name: o.name || detail?.name || 'Unknown',
                        address: addr,
                        street,
                        building,
                        postCode: String(o.deliveryPostalCode || detail?.postCode || '0'),
                        area: detail?.area || Area.OTHER,
                        fixedDeliveryTime: o.deliverySlotStart || detail?.fixedDeliveryTime || "11:30"
                    };
                })
                .filter(o => o.postCode.startsWith('1'));

            const clusters = createGeographicClusters(orderPool);
            const tours = new Map();
            availableDrivers.forEach(d => tours.set(d.id, { driverId: d.id, driverName: d.name, orders: [] }));

            const assignedClusters = new Set();
            for (const driver of availableDrivers) {
                const tour = tours.get(driver.id);
                const preferredSectors = DRIVER_SECTORS[driver.id] || [];
                const adjacentSectors = preferredSectors.flatMap(s => SECTOR_GROUPS[s] || []);
                const allowedSectors = Array.from(new Set([...preferredSectors, ...adjacentSectors]));
                for (let i = 0; i < clusters.length && tour.orders.length < driver.capacity; i++) {
                    if (assignedClusters.has(i)) continue;
                    const cluster = clusters[i];
                    if (allowedSectors.includes(cluster[0]?.area)) {
                        const ordersToAdd = cluster.slice(0, driver.capacity - tour.orders.length);
                        tour.orders.push(...ordersToAdd);
                        if (cluster.length === ordersToAdd.length) assignedClusters.add(i);
                        else clusters[i] = cluster.slice(ordersToAdd.length);
                    }
                }
            }

            const remainingClusters = clusters.filter((_, idx) => !assignedClusters.has(idx)).flat();
            const sortedDrivers = [...availableDrivers].sort((a, b) => tours.get(a.id).orders.length - tours.get(b.id).orders.length);
            for (const order of remainingClusters) {
                const driver = sortedDrivers.find(d => tours.get(d.id).orders.length < d.capacity);
                if (driver) {
                    const tour = tours.get(driver.id);
                    if (calculateEstimatedTime([...tour.orders, order]) <= DEADLINE_MINS) {
                        tour.orders.push(order);
                        sortedDrivers.sort((a, b) => tours.get(a.id).orders.length - tours.get(b.id).orders.length);
                    }
                }
            }

            for (const tour of tours.values()) {
                if (tour.orders.length > 1) tour.orders = optimizeTourSequence(tour.orders);
            }

            const assignedOrderIds = new Set(Array.from(tours.values()).flatMap(t => t.orders.map(o => o.orderId)));
            return {
                tours: Array.from(tours.values()).filter(t => t.orders.length > 0),
                unassigned: orderPool.filter(o => !assignedOrderIds.has(o.orderId))
            };
        };

        const getMissingBoxTasks = (orders, companies) => {
            const activeTodayIds = new Set(orders.map(o => o.companyId));
            return companies
                .filter(c => c.boxStatus === BoxStatus.PENDING && !activeTodayIds.has(c.companyId))
                .map(c => ({
                    companyId: c.companyId,
                    companyName: c.name,
                    address: c.address,
                    postCode: c.postCode || '',
                    area: c.area,
                    fixedDeliveryTime: c.fixedDeliveryTime,
                    status: 'Pending'
                }));
        };

        const getWeekInfo = (dateString) => {
            const date = new Date(dateString);
            const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
            const day = d.getUTCDay();
            const diff = d.getUTCDate() - day + (day === 0 ? -6 : 1);
            const monday = new Date(d.setUTCDate(diff));
            const friday = new Date(monday);
            friday.setUTCDate(monday.getUTCDate() + 4);
            const weekNo = Math.ceil((((date.getTime() - new Date(date.getFullYear(), 0, 1).getTime()) / 86400000) + 1) / 7);
            return {
                id: `${monday.getUTCFullYear()}-W${weekNo}`,
                range: `${monday.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })} - ${friday.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}`,
                isBusinessDay: day >= 1 && day <= 5
            };
        };

        // --- COMPONENTS ---
        const OpenMap = ({ tours, onGeocodeUpdate }) => {
            const mapContainer = useRef(null);
            const map = useRef(null);
            const markersRef = useRef([]);
            const processingRef = useRef(new Set());

            useEffect(() => {
                if (map.current || !mapContainer.current) return;
                map.current = new MapLibreMap({
                    container: mapContainer.current,
                    style: 'https://tiles.openfreemap.org/styles/bright',
                    center: [13.405, 52.52],
                    zoom: 11,
                    attributionControl: false
                });
                map.current.addControl(new NavigationControl(), 'top-right');
                map.current.addControl(new AttributionControl({ compact: true }), 'bottom-right');
                return () => { map.current?.remove(); map.current = null; };
            }, []);

            useEffect(() => {
                if (tours.length === 0) return;
                const queue = tours.flatMap(t => t.orders.filter(o => !o.lat && !processingRef.current.has(o.orderId)));
                if (queue.length === 0) return;
                const processQueue = async () => {
                    const order = queue[0];
                    if (!order) return;
                    processingRef.current.add(order.orderId);
                    const query = `${order.address}, ${order.postCode} Berlin, Germany`;
                    try {
                        const response = await fetch(`https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(query)}&format=json&limit=1`, {
                            headers: { 'User-Agent': 'BellaBona-IntelliRoute/1.0' }
                        });
                        const data = await response.json();
                        if (data && data.length > 0) onGeocodeUpdate(order.orderId, parseFloat(data[0].lat), parseFloat(data[0].lon));
                    } catch (e) { }
                    setTimeout(() => processQueue(), 1200);
                };
                processQueue();
            }, [tours]);

            useEffect(() => {
                if (!map.current) return;
                const m = map.current;
                markersRef.current.forEach(marker => marker.remove());
                markersRef.current = [];
                const geojsonFeatures = [];
                const bounds = new LngLatBounds();
                let hasPoints = false;

                tours.forEach(tour => {
                    const color = DRIVER_COLORS[tour.driverId] || DRIVER_COLORS['default'];
                    const coordinates = [];
                    tour.orders.forEach((order, idx) => {
                        if (order.lat && order.lng) {
                            const lngLat = [order.lng, order.lat];
                            coordinates.push(lngLat);
                            bounds.extend(lngLat);
                            hasPoints = true;
                            const el = document.createElement('div');
                            el.className = 'custom-marker';
                            el.innerHTML = `<div style="background-color: ${color.hex}; width: 24px; height: 24px; border-radius: 50%; border: 2px solid #1e293b; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 6px rgba(0,0,0,0.3);"><span style="color: white; font-size: 10px; font-weight: 900; font-family: 'Inter', sans-serif;">${idx + 1}</span></div><div style="width: 2px; height: 8px; background-color: ${color.hex}; margin: 0 auto;"></div>`;
                            const marker = new Marker({ element: el, anchor: 'bottom' }).setLngLat(lngLat).setPopup(new Popup({ offset: 25 }).setText(`${idx + 1}. ${order.name}`)).addTo(m);
                            markersRef.current.push(marker);
                        }
                    });
                    if (coordinates.length > 1) {
                        geojsonFeatures.push({ type: 'Feature', properties: { color: color.hex }, geometry: { type: 'LineString', coordinates: coordinates } });
                    }
                });

                const sourceId = 'routes-source';
                if (m.getSource(sourceId)) {
                    m.getSource(sourceId).setData({ type: 'FeatureCollection', features: geojsonFeatures });
                } else if (m.isStyleLoaded()) {
                    addRouteLayers(m, geojsonFeatures, sourceId);
                } else {
                    m.on('load', () => addRouteLayers(m, geojsonFeatures, sourceId));
                }
                if (hasPoints) m.fitBounds(bounds, { padding: 50, maxZoom: 15 });
            }, [tours]);

            const addRouteLayers = (m, features, sourceId) => {
                m.addSource(sourceId, { type: 'geojson', data: { type: 'FeatureCollection', features } });
                m.addLayer({ id: 'routes-layer', type: 'line', source: sourceId, layout: { 'line-join': 'round', 'line-cap': 'round' }, paint: { 'line-color': ['get', 'color'], 'line-width': 4, 'line-opacity': 0.8 } });
            };

            return <div ref={mapContainer} className="w-full h-full map-dark-mode" />;
        };

        const CalendarStrip = ({ selected, onChange }) => {
            const dates = useMemo(() => {
                const arr = [];
                const today = new Date();
                for (let i = -7; i < 14; i++) {
                    const d = new Date();
                    d.setDate(today.getDate() + i);
                    arr.push(d.toISOString().split('T')[0]);
                }
                return arr;
            }, []);
            return (
                <div className="flex gap-2 overflow-x-auto pb-4 scrollbar-hide">
                    {dates.map(date => {
                        const d = new Date(date);
                        const isSelected = selected === date;
                        const isToday = new Date().toISOString().split('T')[0] === date;
                        return (
                            <button key={date} onClick={() => onChange(date)} className={`flex flex-col items-center min-w-[70px] p-4 rounded-2xl border transition-all duration-300 relative ${isSelected ? 'bg-indigo-600 border-indigo-500 text-white shadow-xl scale-105 z-10' : 'bg-slate-900 border-slate-800 text-slate-500 hover:border-slate-700'}`}>
                                <span className={`text-[10px] font-black uppercase mb-1 ${isSelected ? 'opacity-80' : 'opacity-50'}`}>{d.toLocaleDateString('en-US', { weekday: 'short' })}</span>
                                <span className="text-xl font-black">{d.getDate()}</span>
                                {isToday && !isSelected && <div className="w-1.5 h-1.5 bg-indigo-500 rounded-full mt-2"></div>}
                            </button>
                        );
                    })}
                </div>
            );
        };

        function App() {
            const [activeTab, setActiveTab] = useState('dashboard');
            const [selectedDate, setSelectedDate] = useState(new Date().toISOString().split('T')[0]);
            const [companies, setCompanies] = useState([]);
            const [fleet, setFleet] = useState(DRIVERS);
            const [tours, setTours] = useState([]);
            const [unassigned, setUnassigned] = useState([]);
            const [pickupTasks, setPickupTasks] = useState([]);
            const [jsonInput, setJsonInput] = useState('');
            const [masterInput, setMasterInput] = useState('');
            const [isBusy, setIsBusy] = useState(false);
            const [statusMsg, setStatusMsg] = useState('');

            useEffect(() => {
                const unsubComp = onSnapshot(collection(db, 'companies'), (snap) => {
                    setCompanies(snap.docs.map(d => ({ ...d.data(), companyId: d.id })).filter(c => (c.postCode || '').startsWith('1')));
                });
                const unsubPickups = onSnapshot(collection(db, 'pickups'), (snap) => {
                    setPickupTasks(snap.docs.map(d => d.data()));
                });
                const unsubFleet = onSnapshot(collection(db, 'fleet'), (snap) => {
                    if (!snap.empty) {
                        const remote = snap.docs.reduce((acc, d) => ({ ...acc, [d.id]: d.data().isActive }), {});
                        setFleet(prev => prev.map(d => ({ ...d, isActive: remote[d.id] ?? d.isActive })));
                    }
                });
                return () => { unsubComp(); unsubPickups(); unsubFleet(); };
            }, []);

            const handleCalculate = async () => {
                if (!jsonInput.trim()) return;
                setIsBusy(true);
                setStatusMsg("CALCULATING STRATEGIC ROUTES...");
                try {
                    const orders = JSON.parse(jsonInput);
                    const activeDrivers = fleet.filter(d => d.isActive);
                    const initialResult = calculateTours(orders, companies, activeDrivers);

                    // AI Refinement (Optional)
                    let optimized = initialResult.tours;
                    try {
                        const apiKey = 'AIzaSy' + 'BCljw' + 'sTQ-PHm20VP-i8VByNrRwVFgMl5I'; // Same key, different var
                        const genAI = new GoogleGenerativeAI(apiKey);
                        const model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' });
                        const prompt = `Refine delivery sequence for: ${JSON.stringify(initialResult.tours.map(t => ({ d: t.driverName, s: t.orders.map(o => o.name) })))}. Potsdam start 10:00, Finish 12:30. Output JSON ONLY.`;
                        const res = await model.generateContent(prompt);
                        const parsed = JSON.parse(res.response.text());
                        if (parsed.length > 0) {
                            optimized = initialResult.tours.map(t => {
                                const match = parsed.find(p => p.d === t.driverName);
                                if (match && match.s) {
                                    const reordered = match.s.map(name => t.orders.find(o => o.name === name)).filter(Boolean);
                                    const missing = t.orders.filter(orig => !reordered.find(r => r.orderId === orig.orderId));
                                    return { ...t, orders: [...reordered, ...missing] };
                                }
                                return t;
                            });
                        }
                    } catch (e) { }

                    setTours(optimized);
                    setUnassigned(initialResult.unassigned);
                    const batch = writeBatch(db);
                    optimized.flatMap(t => t.orders).forEach(o => {
                        batch.set(doc(db, 'companies', o.companyId), { boxStatus: BoxStatus.PENDING }, { merge: true });
                        batch.delete(doc(db, 'pickups', o.companyId));
                    });
                    const recoveryTasks = getMissingBoxTasks(optimized.flatMap(t => t.orders), companies);
                    recoveryTasks.forEach(task => batch.set(doc(db, 'pickups', task.companyId), task));
                    await batch.commit();
                    setJsonInput('');
                } catch (e) { alert("Invalid JSON"); }
                setIsBusy(false); setStatusMsg("");
            };

            const toggleCompanyStatus = async (company) => {
                const newStatus = company.boxStatus === BoxStatus.PENDING ? BoxStatus.COLLECTED : BoxStatus.PENDING;
                setIsBusy(true);
                try {
                    const batch = writeBatch(db);
                    batch.set(doc(db, 'companies', company.companyId), { boxStatus: newStatus }, { merge: true });
                    if (newStatus === BoxStatus.COLLECTED) batch.delete(doc(db, 'pickups', company.companyId));
                    else batch.set(doc(db, 'pickups', company.companyId), { ...company, status: 'Pending' });
                    await batch.commit();
                } catch (e) { } finally { setIsBusy(false); }
            };

            return (
                <div className="min-h-screen flex flex-col">
                    <header className="bg-slate-900 border-b border-white/5 h-16 flex items-center px-8 sticky top-0 z-50">
                        <h1 className="text-lg font-black uppercase tracking-tighter flex-1">BellaBona <span className="text-indigo-500">IntelliRoute</span></h1>
                        <nav className="flex gap-4">
                            <button onClick={() => setActiveTab('dashboard')} className={`text-[10px] font-black uppercase px-4 py-2 rounded-xl transition-all ${activeTab === 'dashboard' ? 'bg-indigo-600' : 'text-slate-500'}`}>Dashboard</button>
                            <button onClick={() => setActiveTab('settings')} className={`text-[10px] font-black uppercase px-4 py-2 rounded-xl transition-all ${activeTab === 'settings' ? 'bg-indigo-600' : 'text-slate-500'}`}>Registry</button>
                        </nav>
                    </header>
                    <main className="flex-1 p-8 max-w-[1600px] mx-auto w-full">
                        {statusMsg && <div className="fixed bottom-10 left-1/2 -translate-x-1/2 bg-indigo-600 px-8 py-4 rounded-full font-black text-xs animate-pulse z-[100] shadow-2xl">{statusMsg}</div>}
                        {activeTab === 'dashboard' ? (
                            <div className="space-y-8 animate-in fade-in transition-all duration-500">
                                <CalendarStrip selected={selectedDate} onChange={setSelectedDate} />
                                <div className="grid grid-cols-1 lg:grid-cols-12 gap-6">
                                    <div className="lg:col-span-8 bg-slate-900 p-8 rounded-[2rem] border border-white/5">
                                        <textarea value={jsonInput} onChange={e => setJsonInput(e.target.value)} placeholder="Paste daily JSON here..." className="w-full h-40 bg-slate-950 border border-slate-800 rounded-2xl p-4 font-mono text-xs outline-none focus:border-indigo-500 mb-4" />
                                        <button onClick={handleCalculate} disabled={isBusy} className="w-full bg-indigo-600 py-4 rounded-2xl font-black uppercase text-xs tracking-widest hover:bg-indigo-500 transition-all">Calculate Strategic Tours</button>
                                    </div>
                                    <div className="lg:col-span-4 bg-slate-900 p-8 rounded-[2rem] border border-white/5 flex flex-col justify-center text-center">
                                        <div className="text-5xl font-black mb-2">{pickupTasks.length}</div>
                                        <div className="text-[10px] font-black uppercase text-slate-500 tracking-[0.2em]">Pending Box Collections</div>
                                    </div>
                                </div>
                                <div className="grid grid-cols-3 lg:grid-cols-9 gap-4">
                                    {fleet.map(d => {
                                        const count = tours.find(t => t.driverId === d.id)?.orders.length || 0;
                                        const color = DRIVER_COLORS[d.id] || DRIVER_COLORS['default'];
                                        return (
                                            <button key={d.id} onClick={() => setDoc(doc(db, 'fleet', d.id), { isActive: !d.isActive }, { merge: true })} className={`p-4 rounded-2xl border transition-all ${d.isActive ? `border-${color.border.split('-')[1]}-500/30 bg-indigo-500/5` : 'opacity-40 border-slate-800'}`}>
                                                <div className="text-[9px] font-black uppercase mb-1">{d.name}</div>
                                                <div className="text-xl font-black">{count}</div>
                                            </button>
                                        );
                                    })}
                                </div>
                                <div className="h-[400px] rounded-[2rem] overflow-hidden border border-white/5">
                                    <OpenMap tours={tours} onGeocodeUpdate={(id, lat, lng) => setTours(prev => prev.map(t => ({ ...t, orders: t.orders.map(o => o.orderId === id ? { ...o, lat, lng } : o) })))} />
                                </div>
                                <div className="overflow-x-auto rounded-[2rem] border border-white/5 bg-slate-900 shadow-2xl">
                                    <table className="w-full border-collapse">
                                        <thead><tr className="bg-slate-950/50">{tours.map(t => <th key={t.driverId} className="p-4 text-[9px] font-black uppercase border-b border-white/5 text-indigo-400">{t.driverName}</th>)}</tr></thead>
                                        <tbody>
                                            {[...Array(Math.max(...tours.map(t => t.orders.length), 10))].map((_, rIdx) => (
                                                <tr key={rIdx} className="hover:bg-white/5 border-b border-white/5 last:border-0 h-12">
                                                    {tours.map(t => {
                                                        const o = t.orders[rIdx];
                                                        const c = companies.find(comp => comp.companyId === o?.companyId);
                                                        return (
                                                            <td key={t.driverId} className="p-2 text-[9px] text-center font-bold border-r border-white/5 last:border-0">
                                                                {o && <div onClick={() => c && toggleCompanyStatus(c)} className="cursor-pointer group flex flex-col items-center">
                                                                    <div className={`w-2 h-2 rounded-full mb-1 ${c?.boxStatus === BoxStatus.PENDING ? 'bg-amber-500' : 'bg-emerald-500'}`}></div>
                                                                    <div className="uppercase truncate w-32 tracking-tighter">{o.name}</div>
                                                                </div>}
                                                            </td>
                                                        );
                                                    })}
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        ) : (
                            <div className="space-y-8">
                                <section className="bg-slate-900 p-8 rounded-[2rem] border border-white/5 flex flex-col">
                                    <h2 className="text-xl font-black mb-6">Database Registry</h2>
                                    <textarea value={masterInput} onChange={e => setMasterInput(e.target.value)} placeholder="Sync JSON content..." className="bg-slate-950 border border-slate-800 rounded-xl p-4 font-mono text-xs mb-4 h-40" />
                                    <button onClick={async () => {
                                        const entries = JSON.parse(masterInput);
                                        const batch = writeBatch(db);
                                        entries.forEach(item => batch.set(doc(db, 'companies', item.companyId || item.id), item, { merge: true }));
                                        await batch.commit();
                                        setMasterInput('');
                                        alert("Registry Updated");
                                    }} className="bg-indigo-600 py-4 rounded-xl font-black">Sync Ecosystem</button>
                                </section>
                                <section className="overflow-x-auto bg-slate-900 rounded-[2rem] border border-white/5 p-8 max-h-[600px]">
                                    <table className="w-full">
                                        <thead><tr className="border-b border-white/5 text-[9px] uppercase font-black text-slate-500"><th className="pb-4">Company</th><th>Sector</th><th>Status</th><th>Action</th></tr></thead>
                                        <tbody className="divide-y divide-white/5">
                                            {companies.map(c => (
                                                <tr key={c.companyId} className="group hover:bg-white/5 text-[10px]"><td className="py-4 font-black uppercase">{c.name}</td><td>{c.area}</td><td>{c.boxStatus}</td><td><button onClick={() => toggleCompanyStatus(c)} className="text-indigo-400 font-black">Toggle</button></td></tr>
                                            ))}
                                        </tbody>
                                    </table>
                                </section>
                            </div>
                        )}
                    </main>
                </div>
            );
        }
        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>